

----- app\api\v1\jerseys\team\[teamId]\route.ts -----

// src/app/api/v1/jerseys/team/[teamId]/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Handle team jersey detail requests ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getTeamJerseyDetails } from "@/lib/db/queries/jerseys";

/**
 * GET /api/v1/jerseys/team/[teamId]
 * Get full team jersey details
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { teamId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    if (!hasPermission(session, "manage_jerseys")) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    const team = await getTeamJerseyDetails(params.teamId);

    if (!team) {
      return NextResponse.json({ error: "Team not found" }, { status: 404 });
    }

    return NextResponse.json({ team });
  } catch (error: any) {
    console.error("GET /api/v1/jerseys/team/[teamId] error:", error);
    return NextResponse.json(
      { error: error.message || "Failed to fetch team jersey details" },
      { status: 500 }
    );
  }
}


----- app\api\v1\league\cities\route.ts -----

// src/app/api/v1/league/cities/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Cities API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import {
  getAllCities,
  createCity,
  updateCity,
  deleteCity,
  cityNameExists,
} from "@/lib/db/queries/cities";
import { z } from "zod";

import { createCitySchema, updateCitySchema } from "@/lib/validations/city";

/**
 * GET /api/v1/league/cities
 * Get all cities (EXECUTIVE only)
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_cities")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const cities = await getAllCities();

    return NextResponse.json({ success: true, data: cities }, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching cities:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch cities" },
      { status: 500 }
    );
  }
}

/**
 * POST /api/v1/league/cities
 * Create city (EXECUTIVE only)
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    console.log("Session:", session); // Add this
    console.log("Has permission:", hasPermission(session, "manage_cities")); // Add this

    if (!session || !hasPermission(session, "manage_cities")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = createCitySchema.parse(body);

    // Check if city exists
    const exists = await cityNameExists(
      validatedData.cityName,
      validatedData.region,
      validatedData.country
    );

    if (exists) {
      return NextResponse.json(
        { success: false, error: "City already exists in this region" },
        { status: 409 }
      );
    }

    const city = await createCity(validatedData);

    return NextResponse.json({ success: true, data: city }, { status: 201 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error creating city:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to create city" },
      { status: 500 }
    );
  }
}

/**
 * PATCH /api/v1/league/cities
 * Update city (EXECUTIVE only)
 */
export async function PATCH(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_cities")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = updateCitySchema.parse(body);

    const { id, ...updateData } = validatedData;

    const city = await updateCity(id, updateData);

    if (!city) {
      return NextResponse.json(
        { success: false, error: "City not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, data: city }, { status: 200 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error updating city:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to update city" },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/v1/league/cities
 * Delete city (EXECUTIVE only)
 */
export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_cities")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const id = searchParams.get("id");

    if (!id) {
      return NextResponse.json(
        { success: false, error: "City ID is required" },
        { status: 400 }
      );
    }

    await deleteCity(id);

    return NextResponse.json(
      { success: true, message: "City deleted successfully" },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error deleting city:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to delete city" },
      { status: 500 }
    );
  }
}


----- app\api\v1\league\levels\route.ts -----

// src/app/api/v1/league/levels/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Levels API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import {
  getAllLevels,
  createLevel,
  updateLevel,
  levelNameExists,
  gradeExists,
} from "@/lib/db/queries/levels";
import { createLevelSchema, updateLevelSchema } from "@/lib/validations/level";
import { z } from "zod";

/**
 * GET /api/v1/league/levels
 * Get all levels (EXECUTIVE only)
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_levels")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const activeFilter = searchParams.get("active");
    const activeOnly = searchParams.get("activeOnly") === "true";

    const levels = await getAllLevels(activeFilter, activeOnly);

    return NextResponse.json({ success: true, data: levels }, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching levels:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch levels" },
      { status: 500 }
    );
  }
}

/**
 * POST /api/v1/league/levels
 * Create level (EXECUTIVE only)
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_levels")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = createLevelSchema.parse(body);

    // Check if level name exists
    const nameExists = await levelNameExists(validatedData.name);
    if (nameExists) {
      return NextResponse.json(
        { success: false, error: "Level name already exists" },
        { status: 409 }
      );
    }

    // Check if grade exists
    // const gradeAlreadyExists = await gradeExists(validatedData.grade);
    // if (gradeAlreadyExists) {
    //   return NextResponse.json(
    //     { success: false, error: "Grade number already exists" },
    //     { status: 409 }
    //   );
    // }

    const level = await createLevel(validatedData);

    return NextResponse.json({ success: true, data: level }, { status: 201 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error creating level:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to create level" },
      { status: 500 }
    );
  }
}

/**
 * PATCH /api/v1/league/levels
 * Update level (EXECUTIVE only)
 */
export async function PATCH(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_levels")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = updateLevelSchema.parse(body);

    const { id, ...updateData } = validatedData;

    // Check if name exists (excluding current level)
    if (updateData.name) {
      const nameExists = await levelNameExists(updateData.name, id);
      if (nameExists) {
        return NextResponse.json(
          { success: false, error: "Level name already exists" },
          { status: 409 }
        );
      }
    }

    // // Check if grade exists (excluding current level)
    // if (updateData.grade) {
    //   const gradeAlreadyExists = await gradeExists(updateData.grade, id);
    //   if (gradeAlreadyExists) {
    //     return NextResponse.json(
    //       { success: false, error: "Grade number already exists" },
    //       { status: 409 }
    //     );
    //   }
    // }

    const level = await updateLevel(id, updateData);

    if (!level) {
      return NextResponse.json(
        { success: false, error: "Level not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, data: level }, { status: 200 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error updating level:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to update level" },
      { status: 500 }
    );
  }
}


----- app\api\v1\league\locations\route.ts -----

// src/app/api/v1/league/locations/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Locations API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import {
  getAllLocations,
  createLocation,
  updateLocation,
  deleteLocation,
  locationHasActiveDivisions,
} from "@/lib/db/queries/locations";
import {
  createLocationSchema,
  updateLocationSchema,
} from "@/lib/validations/location";
import { z } from "zod";

/**
 * GET /api/v1/league/locations
 * Get all locations (EXECUTIVE only)
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_locations")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const cityId = searchParams.get("cityId");

    let locations;
    if (cityId) {
      const { getLocationsByCity } = await import("@/lib/db/queries/locations");
      locations = await getLocationsByCity(cityId);
    } else {
      locations = await getAllLocations();
    }

    return NextResponse.json(
      { success: true, data: locations },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error fetching locations:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch locations" },
      { status: 500 }
    );
  }
}

/**
 * POST /api/v1/league/locations
 * Create location (EXECUTIVE only)
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_locations")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = createLocationSchema.parse(body);

    const location = await createLocation(validatedData);

    return NextResponse.json(
      { success: true, data: location },
      { status: 201 }
    );
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error creating location:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to create location" },
      { status: 500 }
    );
  }
}

/**
 * PATCH /api/v1/league/locations
 * Update location (EXECUTIVE only)
 */
export async function PATCH(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_locations")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = updateLocationSchema.parse(body);

    const { id, ...updateData } = validatedData;

    const location = await updateLocation(id, updateData);

    if (!location) {
      return NextResponse.json(
        { success: false, error: "Location not found" },
        { status: 404 }
      );
    }

    return NextResponse.json(
      { success: true, data: location },
      { status: 200 }
    );
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error updating location:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to update location" },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/v1/league/locations
 * Delete location (EXECUTIVE only)
 */
export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_locations")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const id = searchParams.get("id");

    if (!id) {
      return NextResponse.json(
        { success: false, error: "Location ID is required" },
        { status: 400 }
      );
    }

    // Check if location has active divisions
    const hasActiveDivisions = await locationHasActiveDivisions(id);
    if (hasActiveDivisions) {
      return NextResponse.json(
        {
          success: false,
          error: "Cannot delete location with active divisions",
        },
        { status: 400 }
      );
    }

    await deleteLocation(id);

    return NextResponse.json(
      { success: true, message: "Location deleted successfully" },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error deleting location:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to delete location" },
      { status: 500 }
    );
  }
}


----- app\api\v1\league\prices\route.ts -----

// src/app/api/v1/league/prices/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Prices API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import {
  getAllPrices,
  createPrice,
  stripePriceIdExists,
} from "@/lib/db/queries/prices";
import { createPriceSchema } from "@/lib/validations/price";
import { z } from "zod";

/**
 * GET /api/v1/league/prices
 * Get all prices (EXECUTIVE only)
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_prices")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const prices = await getAllPrices();

    return NextResponse.json({ success: true, data: prices }, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching prices:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch prices" },
      { status: 500 }
    );
  }
}

/**
 * POST /api/v1/league/prices
 * Create price (EXECUTIVE only)
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_prices")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = createPriceSchema.parse(body);

    // Check if Stripe price ID already exists
    const exists = await stripePriceIdExists(validatedData.priceId);
    if (exists) {
      return NextResponse.json(
        { success: false, error: "This Stripe price ID is already registered" },
        { status: 409 }
      );
    }

    const price = await createPrice(validatedData);

    return NextResponse.json({ success: true, data: price }, { status: 201 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error creating price:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to create price" },
      { status: 500 }
    );
  }
}


----- app\api\v1\payments\card-info\[customerId]\route.ts -----

// src/app/api/v1/[cityId]/payments/card-info/[customerId]/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Get customer card info API ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getCustomerCardInfo } from "@/lib/services/stripe-customer-service";

/**
 * GET /api/v1/[cityId]/payments/card-info/[customerId]
 * Get customer's card information
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { cityId: string; customerId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "view_payments")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const cardInfo = await getCustomerCardInfo(params.customerId);

    return NextResponse.json(
      { success: true, data: cardInfo },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error getting card info:", error);
    return NextResponse.json(
      { success: false, error: "Failed to get card info" },
      { status: 500 }
    );
  }
}


----- app\api\v1\payments\charge-card\route.ts -----

// src/app/api/v1/[cityId]/payments/charge-card/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Charge customer card API ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { connectDB } from "@/lib/db/mongodb";
import { chargeCustomerCard } from "@/lib/services/stripe-customer-service";
import Player from "@/models/Player";
import PaymentMethod from "@/models/PaymentMethod";
import twilio from "twilio";

const twilioClient = twilio(
  process.env.TWILIO_ACCOUNT_SID,
  process.env.TWILIO_AUTH_TOKEN
);

/**
 * POST /api/v1/[cityId]/payments/charge-card
 * Charge customer's card on file
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_payments")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { playerId, paymentMethodId, paymentNumber, amount } =
      await request.json();

    await connectDB();

    // Get player with populated fields
    const player = await Player.findById(playerId)
      .populate("user", "name email phoneNumber")
      .populate("team", "teamName")
      .lean();

    if (!player || !player.customerId) {
      return NextResponse.json(
        { success: false, error: "Player not found or no Stripe customer" },
        { status: 404 }
      );
    }

    // Get payment method
    const paymentMethod = await PaymentMethod.findById(paymentMethodId).lean();

    if (!paymentMethod) {
      return NextResponse.json(
        { success: false, error: "Payment method not found" },
        { status: 404 }
      );
    }

    // Charge card via Stripe
    try {
      const paymentIntent = await chargeCustomerCard({
        customerId: player.customerId,
        amount,
        description: `${
          (player.team as any)?.teamName || "Team"
        } - Payment #${paymentNumber} - ${player.playerName}`,
        metadata: {
          playerId: player._id.toString(),
          paymentMethodId: paymentMethod._id.toString(),
          paymentNumber: paymentNumber.toString(),
          chargedBy: session.user?.email || "admin",
        },
      });

      if (paymentIntent.status !== "succeeded") {
        throw new Error(
          paymentIntent.last_payment_error?.message || "Payment failed"
        );
      }

      // Create new FULL_PAYMENT PaymentMethod for this installment
      const manualPayment = new PaymentMethod({
        paymentType: "FULL_PAYMENT",
        pricingTier: paymentMethod.pricingTier,
        originalPrice: amount / 100, // Convert back to dollars
        amountPaid: amount / 100,
        status: "COMPLETED",
        player: player._id,
        division: paymentMethod.division,
        isManualInstallment: true,
        installmentNumber: paymentNumber,
        replacedPaymentMethod: paymentMethod._id,
        stripePaymentIntentId: paymentIntent.id,
      });

      await manualPayment.save();

      // Add to player's payment methods
      await Player.findByIdAndUpdate(player._id, {
        $push: { paymentMethods: manualPayment._id },
      });

      // Mark original subscription payment as replaced
      await PaymentMethod.updateOne(
        {
          _id: paymentMethod._id,
          "installments.subscriptionPayments.paymentNumber": paymentNumber,
        },
        {
          $set: {
            "installments.subscriptionPayments.$.replacedBy": manualPayment._id,
          },
        }
      );

      // Send SMS confirmation to player
      const userPhone = (player.user as any)?.phoneNumber;
      if (userPhone) {
        try {
          await twilioClient.messages.create({
            body: `Hi ${
              player.playerName
            }, your payment #${paymentNumber} for $${
              amount / 100
            } has been processed successfully. You'll receive a receipt from Stripe via email.`,
            from: process.env.TWILIO_MESSAGING_SERVICE_SID,
            to: userPhone,
          });
        } catch (smsError) {
          console.error("Failed to send SMS confirmation:", smsError);
          // Don't fail the whole request if SMS fails
        }
      }

      return NextResponse.json(
        {
          success: true,
          data: {
            paymentIntentId: paymentIntent.id,
            manualPaymentId: manualPayment._id,
            amount: amount / 100,
          },
        },
        { status: 200 }
      );
    } catch (stripeError: any) {
      // Handle Stripe-specific errors
      return NextResponse.json(
        {
          success: false,
          error: stripeError.message || "Card charge failed",
        },
        { status: 400 }
      );
    }
  } catch (error: any) {
    console.error("Error charging card:", error);
    return NextResponse.json(
      { success: false, error: "Failed to charge card" },
      { status: 500 }
    );
  }
}


----- app\api\v1\payments\export\route.ts -----

// src/app/api/v1/payments/export/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Export payments to CSV ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getPlayersWithPaymentStatus } from "@/lib/db/queries/payments";

/**
 * POST /api/v1/payments/export
 * Export payment data to CSV
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "view_payments")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { filters } = await request.json();

    const players = await getPlayersWithPaymentStatus({
      locationId: filters?.location,
      divisionId: filters?.division,
      teamId: filters?.team,
      paymentStatusFilter: filters?.payment || "all",
      search: filters?.search,
    });

    // Create CSV content
    const headers = [
      "Player Name",
      "Email",
      "Phone",
      "Team",
      "Division",
      "Location",
      "Payment Status",
      "Payment Type",
      "Pricing Tier",
      "Registration Date",
      "Payments Completed",
      "Failed Payments",
    ];

    const rows = players.map((player: any) => {
      const paymentMethod = player.paymentMethod;
      let paymentsCompleted = "N/A";
      let failedPayments = "N/A";

      if (paymentMethod?.paymentType === "INSTALLMENTS") {
        const subscriptionPayments =
          paymentMethod.installments?.subscriptionPayments || [];
        const completed = subscriptionPayments.filter(
          (p: any) => p.status === "succeeded"
        ).length;
        const failed = subscriptionPayments.filter(
          (p: any) => p.status === "failed"
        ).length;
        paymentsCompleted = `${completed}/8`;
        failedPayments = failed.toString();
      }

      return [
        player.playerName,
        player.user?.email || "",
        player.user?.phoneNumber || "",
        player.team?.teamName || "No Team",
        player.division?.divisionName || "",
        player.division?.location?.name || "",
        player.paymentStatus,
        paymentMethod?.paymentType || "None",
        paymentMethod?.pricingTier || "N/A",
        player.createdAt ? new Date(player.createdAt).toLocaleDateString() : "",
        paymentsCompleted,
        failedPayments,
      ];
    });

    // Convert to CSV format
    const csvContent = [
      headers.join(","),
      ...rows.map((row) =>
        row.map((cell) => `"${String(cell).replace(/"/g, '""')}"`).join(",")
      ),
    ].join("\n");

    // Return as downloadable file
    return new NextResponse(csvContent, {
      status: 200,
      headers: {
        "Content-Type": "text/csv",
        "Content-Disposition": `attachment; filename="payment-report-${
          new Date().toISOString().split("T")[0]
        }.csv"`,
      },
    });
  } catch (error: any) {
    console.error("Error exporting payment data:", error);
    return NextResponse.json(
      { success: false, error: "Failed to export payment data" },
      { status: 500 }
    );
  }
}


----- app\api\v1\payments\route.ts -----

// src/app/api/v1/[cityId]/payments/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Payments API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getPlayersWithPaymentStatus } from "@/lib/db/queries/payments";

/**
 * GET /api/v1/[cityId]/payments
 * Get players with payment status
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "view_payments")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const locationId = searchParams.get("location") || undefined;
    const divisionId = searchParams.get("division") || undefined;
    const teamId = searchParams.get("team") || undefined;
    const paymentStatusFilter = searchParams.get("payment") || "all";
    const search = searchParams.get("search") || undefined;

    const players = await getPlayersWithPaymentStatus({
      cityId: params.cityId,
      locationId,
      divisionId,
      teamId,
      paymentStatusFilter,
      search,
    });

    return NextResponse.json(
      { success: true, data: players },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error fetching payment data:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch payment data" },
      { status: 500 }
    );
  }
}

----- app\api\v1\players\route.ts -----

// src/app/api/v1/players/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Players API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import {
  getPlayers,
  createPlayer,
  updatePlayer,
  deletePlayer,
} from "@/lib/db/queries/players";
import {
  createPlayerSchema,
  updatePlayerSchema,
} from "@/lib/validations/player";
import { z } from "zod";

/**
 * GET /api/v1/players
 * Get players with filters
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "view_players")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1");
    const divisionId = searchParams.get("division") || undefined;
    const locationId = searchParams.get("location") || undefined;
    const teamId = searchParams.get("team") || undefined;
    const activeFilter = (searchParams.get("tab") as any) || "active";
    const freeAgentsOnly = searchParams.get("freeAgents") === "true";
    const hasUserAccount = searchParams.get("hasUser")
      ? searchParams.get("hasUser") === "true"
      : undefined;
    const search = searchParams.get("search") || undefined;

    const result = await getPlayers({
      page,
      divisionId,
      locationId,
      teamId,
      activeFilter,
      freeAgentsOnly,
      hasUserAccount,
      search,
    });

    return NextResponse.json({ success: true, data: result }, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching players:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch players" },
      { status: 500 }
    );
  }
}

/**
 * POST /api/v1/players
 * Create player
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_players")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = createPlayerSchema.parse(body);

    const player = await createPlayer(validatedData);

    return NextResponse.json({ success: true, data: player }, { status: 201 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error creating player:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to create player" },
      { status: 500 }
    );
  }
}

/**
 * PATCH /api/v1/players
 * Update player
 */
export async function PATCH(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_players")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = updatePlayerSchema.parse(body);

    const { id, ...updateData } = validatedData;

    const player = await updatePlayer(id, updateData);

    if (!player) {
      return NextResponse.json(
        { success: false, error: "Player not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, data: player }, { status: 200 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error updating player:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to update player" },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/v1/players?id=xxx
 * Delete player
 */
export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_players")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const playerId = searchParams.get("id");

    if (!playerId) {
      return NextResponse.json(
        { success: false, error: "Player ID is required" },
        { status: 400 }
      );
    }

    await deletePlayer(playerId);

    return NextResponse.json(
      { success: true, message: "Player deleted successfully" },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error deleting player:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to delete player" },
      { status: 500 }
    );
  }
}


----- app\api\v1\players\[id]\route.ts -----

// src/app/api/v1/[cityId]/players/[id]/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Single player API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { updatePlayer, deletePlayer } from "@/lib/db/queries/players";
import { updatePlayerSchema } from "@/lib/validations/player";
import { z } from "zod";

/**
 * PATCH /api/v1/[cityId]/players/[id]
 * Update player
 */
export async function PATCH(
  request: NextRequest,
  { params }: { params: { cityId: string; id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_players")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = updatePlayerSchema.parse(body);

    const { id, ...updateData } = validatedData;

    const player = await updatePlayer(params.id, updateData);

    if (!player) {
      return NextResponse.json(
        { success: false, error: "Player not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, data: player }, { status: 200 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error updating player:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to update player" },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/v1/[cityId]/players/[id]
 * Delete player
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: { cityId: string; id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_players")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    await deletePlayer(params.id);

    return NextResponse.json(
      { success: true, message: "Player deleted successfully" },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error deleting player:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to delete player" },
      { status: 500 }
    );
  }
}


----- app\api\v1\teams\route.ts -----

// src/app/api/v1/teams/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Teams API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import {
  getTeams,
  createTeam,
  updateTeam,
  deleteTeam,
  teamCodeExistsInDivision,
} from "@/lib/db/queries/teams";
import { createTeamSchema, updateTeamSchema } from "@/lib/validations/team";
import { z } from "zod";
import Team from "@/models/Team";

/**
 * GET /api/v1/teams
 * Get teams with pagination (EXECUTIVE + COMMISSIONER)
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "view_teams")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1");
    const activeFilter = (searchParams.get("tab") as any) || "active";
    const divisionId = searchParams.get("division") || undefined;
    const locationId = searchParams.get("location") || undefined;
    const search = searchParams.get("search") || undefined;
    const viewMode = (searchParams.get("view") as any) || "card";
    const noCaptain = searchParams.get("noCaptain") === "true";
    const noPlayers = searchParams.get("noPlayers") === "true";

    const result = await getTeams({
      page,
      activeFilter,
      divisionId,
      locationId,
      search,
      viewMode,
      noCaptain,
      noPlayers,
    });

    return NextResponse.json({ success: true, data: result }, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching teams:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch teams" },
      { status: 500 }
    );
  }
}

/**
 * POST /api/v1/teams
 * Create team (EXECUTIVE + COMMISSIONER)
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_teams")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = createTeamSchema.parse(body);

    // Check if team code exists in division
    const codeExists = await teamCodeExistsInDivision(
      validatedData.teamCode,
      validatedData.division
    );

    if (codeExists) {
      return NextResponse.json(
        { success: false, error: "Team code already exists in this division" },
        { status: 409 }
      );
    }

    const team = await createTeam(validatedData);

    return NextResponse.json({ success: true, data: team }, { status: 201 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error creating team:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to create team" },
      { status: 500 }
    );
  }
}

/**
 * PATCH /api/v1/teams
 * Update team (EXECUTIVE + COMMISSIONER)
 */
export async function PATCH(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_teams")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = updateTeamSchema.parse(body);

    const { id, ...updateData } = validatedData;

    // Check team code uniqueness if being updated
    if (updateData.teamCode && updateData.division) {
      const team = await Team.findById(id);
      const codeExists = await teamCodeExistsInDivision(
        updateData.teamCode,
        updateData.division,
        id
      );

      if (codeExists) {
        return NextResponse.json(
          {
            success: false,
            error: "Team code already exists in this division",
          },
          { status: 409 }
        );
      }
    }

    const team = await updateTeam(id, updateData);

    if (!team) {
      return NextResponse.json(
        { success: false, error: "Team not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, data: team }, { status: 200 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error updating team:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to update team" },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/v1/teams
 * Delete team (EXECUTIVE + COMMISSIONER)
 */
export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_teams")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const teamId = searchParams.get("id");

    if (!teamId) {
      return NextResponse.json(
        { success: false, error: "Team ID is required" },
        { status: 400 }
      );
    }

    await deleteTeam(teamId);

    return NextResponse.json(
      { success: true, message: "Team deleted successfully" },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error deleting team:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to delete team" },
      { status: 500 }
    );
  }
}


----- app\api\v1\teams\[teamId]\roster\route.ts -----

// src/app/api/v1/teams/[teamId]/roster/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Team roster management API ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import {
  addPlayerToTeam,
  removePlayerFromTeam,
  getFreeAgentsByDivision,
} from "@/lib/db/queries/players";
import { getTeamById } from "@/lib/db/queries/teams";

/**
 * GET /api/v1/teams/[teamId]/roster
 * Get free agents for team's division
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { teamId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_teams")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const team = await getTeamById(params.teamId);

    if (!team) {
      return NextResponse.json(
        { success: false, error: "Team not found" },
        { status: 404 }
      );
    }

    const divisionId =
      typeof team.division === "object" ? team.division._id : team.division;

    const freeAgents = await getFreeAgentsByDivision(divisionId.toString());

    return NextResponse.json(
      { success: true, data: freeAgents },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error fetching free agents:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch free agents" },
      { status: 500 }
    );
  }
}

/**
 * POST /api/v1/teams/[teamId]/roster
 * Add player to team roster
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { teamId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_teams")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const { playerId } = body;

    if (!playerId) {
      return NextResponse.json(
        { success: false, error: "Player ID is required" },
        { status: 400 }
      );
    }

    await addPlayerToTeam(playerId, params.teamId);

    return NextResponse.json(
      { success: true, message: "Player added to team" },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error adding player to team:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to add player" },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/v1/teams/[teamId]/roster
 * Remove player from team roster
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: { teamId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_teams")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const playerId = searchParams.get("playerId");

    if (!playerId) {
      return NextResponse.json(
        { success: false, error: "Player ID is required" },
        { status: 400 }
      );
    }

    await removePlayerFromTeam(playerId, params.teamId);

    return NextResponse.json(
      { success: true, message: "Player removed from team" },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error removing player from team:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to remove player" },
      { status: 500 }
    );
  }
}


----- app\api\v1\users\search\route.ts -----

// src/app/api/v1/users/search/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * User search API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { connectDB } from "@/lib/db/mongodb";
import User from "@/models/User";

/**
 * GET /api/v1/users/search
 * Search users by email or name
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_players")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const query = searchParams.get("q");

    if (!query || query.length < 2) {
      return NextResponse.json(
        { success: false, error: "Query must be at least 2 characters" },
        { status: 400 }
      );
    }

    await connectDB();

    const users = await User.find({
      $or: [
        { email: { $regex: query, $options: "i" } },
        { name: { $regex: query, $options: "i" } },
      ],
    })
      .select("_id name email")
      .limit(10)
      .lean();

    return NextResponse.json({ success: true, data: users }, { status: 200 });
  } catch (error: any) {
    console.error("Error searching users:", error);
    return NextResponse.json(
      { success: false, error: "Failed to search users" },
      { status: 500 }
    );
  }
}


----- app\api\v1\[cityId]\divisions\route.ts -----

// src/app/api/v1/[cityId]/divisions/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Divisions API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import {
  getDivisions,
  createDivision,
  checkLocationConflict,
  getDivisionById,
  updateDivision,
} from "@/lib/db/queries/divisions";
import {
  createDivisionSchema,
  updateDivisionSchema,
} from "@/lib/validations/division"; // ADD updateDivisionSchema
import { z } from "zod";

/**
 * GET /api/v1/[cityId]/divisions
 * Get divisions with pagination (EXECUTIVE + COMMISSIONER)
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "view_divisions")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1");
    const activeFilter = (searchParams.get("tab") as any) || "all";
    const locationId = searchParams.get("location") || undefined;
    const levelId = searchParams.get("level") || undefined;
    const day = searchParams.get("day") || undefined;
    const search = searchParams.get("search") || undefined;

    const result = await getDivisions({
      page,
      activeFilter,
      locationId,
      levelId,
      day,
      search,
    });

    return NextResponse.json({ success: true, data: result }, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching divisions:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch divisions" },
      { status: 500 }
    );
  }
}

/**
 * POST /api/v1/[cityId]/divisions
 * Create division (EXECUTIVE + COMMISSIONER)
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_divisions")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = createDivisionSchema.parse(body);

    // Check for location conflicts (warning only)
    let conflictWarning = null;
    if (validatedData.startTime && validatedData.endTime) {
      const conflict = await checkLocationConflict(
        validatedData.location,
        validatedData.day,
        validatedData.startTime,
        validatedData.endTime
      );

      if (conflict.hasConflict) {
        conflictWarning = {
          message: `${conflict.conflictingDivision.divisionName} uses this location on ${validatedData.day}s from ${conflict.conflictingDivision.startTime} - ${conflict.conflictingDivision.endTime}`,
        };
      }
    }

    const division = await createDivision({
      ...validatedData,
      city: params.cityId,
    });

    return NextResponse.json(
      {
        success: true,
        data: division,
        warning: conflictWarning,
      },
      { status: 201 }
    );
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error creating division:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to create division" },
      { status: 500 }
    );
  }
}

// src/app/api/v1/[cityId]/divisions/route.ts - Add PATCH method

/**
 * PATCH /api/v1/[cityId]/divisions
 * Update division (EXECUTIVE + COMMISSIONER)
 */
// src/app/api/v1/[cityId]/divisions/route.ts - Update PATCH method

export async function PATCH(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_divisions")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = updateDivisionSchema.parse(body);

    const { id, ...updateData } = validatedData;

    // Check for location conflicts if location/time is being updated
    let conflictWarning = null;
    if (
      updateData.location ||
      updateData.day ||
      updateData.startTime ||
      updateData.endTime
    ) {
      const currentDivision = await getDivisionById(id);

      // Add null check
      if (!currentDivision) {
        return NextResponse.json(
          { success: false, error: "Division not found" },
          { status: 404 }
        );
      }

      // Convert ObjectId to string with proper type handling
      const locationToCheck =
        updateData.location ||
        (typeof currentDivision.location === "object" &&
        currentDivision.location._id
          ? currentDivision.location._id.toString()
          : currentDivision.location?.toString() || "");

      const dayToCheck = updateData.day || currentDivision.day;
      const startTimeToCheck =
        updateData.startTime || currentDivision.startTime;
      const endTimeToCheck = updateData.endTime || currentDivision.endTime;

      if (startTimeToCheck && endTimeToCheck) {
        const conflict = await checkLocationConflict(
          locationToCheck,
          dayToCheck,
          startTimeToCheck,
          endTimeToCheck,
          id
        );

        if (conflict.hasConflict) {
          conflictWarning = {
            message: `${conflict.conflictingDivision.divisionName} uses this location on ${dayToCheck}s from ${conflict.conflictingDivision.startTime} - ${conflict.conflictingDivision.endTime}`,
          };
        }
      }
    }

    const division = await updateDivision(id, updateData);

    if (!division) {
      return NextResponse.json(
        { success: false, error: "Division not found" },
        { status: 404 }
      );
    }

    return NextResponse.json(
      {
        success: true,
        data: division,
        warning: conflictWarning,
      },
      { status: 200 }
    );
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error updating division:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to update division" },
      { status: 500 }
    );
  }
}


----- app\api\v1\[cityId]\locations\route.ts -----

// src/app/api/v1/[cityId]/locations/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Locations API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { getLocationsByCity } from "@/lib/db/queries/locations";

/**
 * GET /api/v1/[cityId]/locations
 * Fetch locations for a specific city
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    // Auth check
    const session = await getServerSession(authOptions);

    if (!session) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Fetch locations
    const locations = await getLocationsByCity(params.cityId);

    return NextResponse.json(
      { success: true, data: locations },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error fetching locations:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch locations" },
      { status: 500 }
    );
  }
}


----- app\api\v1\[cityId]\payments\card-info\[customerId]\route.ts -----

// src/app/api/v1/[cityId]/payments/card-info/[customerId]/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Get customer card info API ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getCustomerCardInfo } from "@/lib/services/stripe-customer-service";

/**
 * GET /api/v1/[cityId]/payments/card-info/[customerId]
 * Get customer's card information
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { cityId: string; customerId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "view_payments")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const cardInfo = await getCustomerCardInfo(params.customerId);

    return NextResponse.json(
      { success: true, data: cardInfo },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error getting card info:", error);
    return NextResponse.json(
      { success: false, error: "Failed to get card info" },
      { status: 500 }
    );
  }
}


----- app\api\v1\[cityId]\payments\charge-card\route.ts -----

// src/app/api/v1/[cityId]/payments/charge-card/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Charge customer card API ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { connectDB } from "@/lib/db/mongodb";
import { chargeCustomerCard } from "@/lib/services/stripe-customer-service";
import Player from "@/models/Player";
import PaymentMethod from "@/models/PaymentMethod";
import twilio from "twilio";

const twilioClient = twilio(
  process.env.TWILIO_ACCOUNT_SID,
  process.env.TWILIO_AUTH_TOKEN
);

/**
 * POST /api/v1/[cityId]/payments/charge-card
 * Charge customer's card on file
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_payments")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { playerId, paymentMethodId, paymentNumber, amount } =
      await request.json();

    await connectDB();

    // Get player with populated fields
    const player = await Player.findById(playerId)
      .populate("user", "name email phoneNumber")
      .populate("team", "teamName")
      .lean();

    if (!player || !player.customerId) {
      return NextResponse.json(
        { success: false, error: "Player not found or no Stripe customer" },
        { status: 404 }
      );
    }

    // Get payment method
    const paymentMethod = await PaymentMethod.findById(paymentMethodId).lean();

    if (!paymentMethod) {
      return NextResponse.json(
        { success: false, error: "Payment method not found" },
        { status: 404 }
      );
    }

    // Charge card via Stripe
    try {
      const paymentIntent = await chargeCustomerCard({
        customerId: player.customerId,
        amount,
        description: `${
          (player.team as any)?.teamName || "Team"
        } - Payment #${paymentNumber} - ${player.playerName}`,
        metadata: {
          playerId: player._id.toString(),
          paymentMethodId: paymentMethod._id.toString(),
          paymentNumber: paymentNumber.toString(),
          chargedBy: session.user?.email || "admin",
        },
      });

      if (paymentIntent.status !== "succeeded") {
        throw new Error(
          paymentIntent.last_payment_error?.message || "Payment failed"
        );
      }

      // Create new FULL_PAYMENT PaymentMethod for this installment
      const manualPayment = new PaymentMethod({
        paymentType: "FULL_PAYMENT",
        pricingTier: paymentMethod.pricingTier,
        originalPrice: amount / 100, // Convert back to dollars
        amountPaid: amount / 100,
        status: "COMPLETED",
        player: player._id,
        division: paymentMethod.division,
        isManualInstallment: true,
        installmentNumber: paymentNumber,
        replacedPaymentMethod: paymentMethod._id,
        stripePaymentIntentId: paymentIntent.id,
      });

      await manualPayment.save();

      // Add to player's payment methods
      await Player.findByIdAndUpdate(player._id, {
        $push: { paymentMethods: manualPayment._id },
      });

      // Mark original subscription payment as replaced
      await PaymentMethod.updateOne(
        {
          _id: paymentMethod._id,
          "installments.subscriptionPayments.paymentNumber": paymentNumber,
        },
        {
          $set: {
            "installments.subscriptionPayments.$.replacedBy": manualPayment._id,
          },
        }
      );

      // Send SMS confirmation to player
      const userPhone = (player.user as any)?.phoneNumber;
      if (userPhone) {
        try {
          await twilioClient.messages.create({
            body: `Hi ${
              player.playerName
            }, your payment #${paymentNumber} for $${
              amount / 100
            } has been processed successfully. You'll receive a receipt from Stripe via email.`,
            from: process.env.TWILIO_MESSAGING_SERVICE_SID,
            to: userPhone,
          });
        } catch (smsError) {
          console.error("Failed to send SMS confirmation:", smsError);
          // Don't fail the whole request if SMS fails
        }
      }

      return NextResponse.json(
        {
          success: true,
          data: {
            paymentIntentId: paymentIntent.id,
            manualPaymentId: manualPayment._id,
            amount: amount / 100,
          },
        },
        { status: 200 }
      );
    } catch (stripeError: any) {
      // Handle Stripe-specific errors
      return NextResponse.json(
        {
          success: false,
          error: stripeError.message || "Card charge failed",
        },
        { status: 400 }
      );
    }
  } catch (error: any) {
    console.error("Error charging card:", error);
    return NextResponse.json(
      { success: false, error: "Failed to charge card" },
      { status: 500 }
    );
  }
}


----- app\api\v1\[cityId]\payments\export\route.ts -----

// src/app/api/v1/[cityId]/payments/export/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Export payments to CSV ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getPlayersWithPaymentStatus } from "@/lib/db/queries/payments";

/**
 * POST /api/v1/[cityId]/payments/export
 * Export payment data to CSV
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "view_payments")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { filters } = await request.json();

    const players = await getPlayersWithPaymentStatus({
      cityId: params.cityId,
      locationId: filters?.location,
      divisionId: filters?.division,
      teamId: filters?.team,
      paymentStatusFilter: filters?.payment || "all",
      search: filters?.search,
    });

    // Create CSV content
    const headers = [
      "Player Name",
      "Email",
      "Phone",
      "Team",
      "Division",
      "Location",
      "Payment Status",
      "Payment Type",
      "Pricing Tier",
      "Registration Date",
      "Payments Completed",
      "Failed Payments",
    ];

    const rows = players.map((player: any) => {
      const paymentMethod = player.paymentMethod;
      let paymentsCompleted = "N/A";
      let failedPayments = "N/A";

      if (paymentMethod?.paymentType === "INSTALLMENTS") {
        const subscriptionPayments =
          paymentMethod.installments?.subscriptionPayments || [];
        const completed = subscriptionPayments.filter(
          (p: any) => p.status === "succeeded"
        ).length;
        const failed = subscriptionPayments.filter(
          (p: any) => p.status === "failed"
        ).length;
        paymentsCompleted = `${completed}/8`;
        failedPayments = failed.toString();
      }

      return [
        player.playerName,
        player.user?.email || "",
        player.user?.phoneNumber || "",
        player.team?.teamName || "No Team",
        player.division?.divisionName || "",
        player.division?.location?.name || "",
        player.paymentStatus,
        paymentMethod?.paymentType || "None",
        paymentMethod?.pricingTier || "N/A",
        player.createdAt ? new Date(player.createdAt).toLocaleDateString() : "",
        paymentsCompleted,
        failedPayments,
      ];
    });

    // Convert to CSV format
    const csvContent = [
      headers.join(","),
      ...rows.map((row) =>
        row.map((cell) => `"${String(cell).replace(/"/g, '""')}"`).join(",")
      ),
    ].join("\n");

    // Return as downloadable file
    return new NextResponse(csvContent, {
      status: 200,
      headers: {
        "Content-Type": "text/csv",
        "Content-Disposition": `attachment; filename="payment-report-${
          new Date().toISOString().split("T")[0]
        }.csv"`,
      },
    });
  } catch (error: any) {
    console.error("Error exporting payment data:", error);
    return NextResponse.json(
      { success: false, error: "Failed to export payment data" },
      { status: 500 }
    );
  }
}


----- app\api\v1\[cityId]\payments\route.ts -----

// src/app/api/v1/[cityId]/payments/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Payments API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getPlayersWithPaymentStatus } from "@/lib/db/queries/payments";

/**
 * GET /api/v1/[cityId]/payments
 * Get players with payment status
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "view_payments")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const locationId = searchParams.get("location") || undefined;
    const divisionId = searchParams.get("division") || undefined;
    const teamId = searchParams.get("team") || undefined;
    const paymentStatusFilter = searchParams.get("payment") || "all";
    const search = searchParams.get("search") || undefined;

    const players = await getPlayersWithPaymentStatus({
      cityId: params.cityId,
      locationId,
      divisionId,
      teamId,
      paymentStatusFilter,
      search,
    });

    return NextResponse.json(
      { success: true, data: players },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error fetching payment data:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch payment data" },
      { status: 500 }
    );
  }
}

----- app\api\v1\[cityId]\players\route.ts -----

// src/app/api/v1/[cityId]/players/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Players API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getPlayers, createPlayer } from "@/lib/db/queries/players";
import { createPlayerSchema } from "@/lib/validations/player";
import { z } from "zod";

/**
 * GET /api/v1/[cityId]/players
 * Get players with filters
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "view_players")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1");
    const divisionId = searchParams.get("division") || undefined;
    const teamId = searchParams.get("team") || undefined;
    const paymentFilter = (searchParams.get("payment") as any) || "all";
    const freeAgentsOnly = searchParams.get("freeAgents") === "true";
    const hasUserAccount = searchParams.get("hasUser")
      ? searchParams.get("hasUser") === "true"
      : undefined;
    const search = searchParams.get("search") || undefined;

    const result = await getPlayers({
      cityId: params.cityId,
      page,
      divisionId,
      teamId,
      paymentFilter,
      freeAgentsOnly,
      hasUserAccount,
      search,
    });

    return NextResponse.json({ success: true, data: result }, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching players:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch players" },
      { status: 500 }
    );
  }
}

/**
 * POST /api/v1/[cityId]/players
 * Create player
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_players")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = createPlayerSchema.parse(body);

    const player = await createPlayer(validatedData);

    return NextResponse.json({ success: true, data: player }, { status: 201 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error creating player:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to create player" },
      { status: 500 }
    );
  }
}


----- app\api\v1\[cityId]\users\search\route.ts -----

// src/app/api/v1/[cityId]/users/search/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * User search API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { connectDB } from "@/lib/db/mongodb";
import User from "@/models/User";

/**
 * GET /api/v1/[cityId]/users/search
 * Search users by email or name
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_players")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const query = searchParams.get("q");

    if (!query || query.length < 2) {
      return NextResponse.json(
        { success: false, error: "Query must be at least 2 characters" },
        { status: 400 }
      );
    }

    await connectDB();

    const users = await User.find({
      $or: [
        { email: { $regex: query, $options: "i" } },
        { name: { $regex: query, $options: "i" } },
      ],
    })
      .select("_id name email")
      .limit(10)
      .lean();

    return NextResponse.json({ success: true, data: users }, { status: 200 });
  } catch (error: any) {
    console.error("Error searching users:", error);
    return NextResponse.json(
      { success: false, error: "Failed to search users" },
      { status: 500 }
    );
  }
}


----- app\globals.css -----

/* src/app/globals.css */

/**
 * Global Styles
 * 
 * Performance Optimization:
 * - Tailwind JIT only includes used classes
 * 
 * Accessibility:
 * - Focus-visible for keyboard navigation
 */

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  * {
    @apply border-gray-200;
  }

  body {
    @apply bg-gray-50 text-gray-900;
  }
  :root {

    --background: 0 0% 100%;

    --foreground: 0 0% 3.9%;

    --card: 0 0% 100%;

    --card-foreground: 0 0% 3.9%;

    --popover: 0 0% 100%;

    --popover-foreground: 0 0% 3.9%;

    --primary: 0 0% 9%;

    --primary-foreground: 0 0% 98%;

    --secondary: 0 0% 96.1%;

    --secondary-foreground: 0 0% 9%;

    --muted: 0 0% 96.1%;

    --muted-foreground: 0 0% 45.1%;

    --accent: 0 0% 96.1%;

    --accent-foreground: 0 0% 9%;

    --destructive: 0 84.2% 60.2%;

    --destructive-foreground: 0 0% 98%;

    --border: 0 0% 89.8%;

    --input: 0 0% 89.8%;

    --ring: 0 0% 3.9%;

    --chart-1: 12 76% 61%;

    --chart-2: 173 58% 39%;

    --chart-3: 197 37% 24%;

    --chart-4: 43 74% 66%;

    --chart-5: 27 87% 67%;

    --radius: 0.5rem
  }
  .dark {

    --background: 0 0% 3.9%;

    --foreground: 0 0% 98%;

    --card: 0 0% 3.9%;

    --card-foreground: 0 0% 98%;

    --popover: 0 0% 3.9%;

    --popover-foreground: 0 0% 98%;

    --primary: 0 0% 98%;

    --primary-foreground: 0 0% 9%;

    --secondary: 0 0% 14.9%;

    --secondary-foreground: 0 0% 98%;

    --muted: 0 0% 14.9%;

    --muted-foreground: 0 0% 63.9%;

    --accent: 0 0% 14.9%;

    --accent-foreground: 0 0% 98%;

    --destructive: 0 62.8% 30.6%;

    --destructive-foreground: 0 0% 98%;

    --border: 0 0% 14.9%;

    --input: 0 0% 14.9%;

    --ring: 0 0% 83.1%;

    --chart-1: 220 70% 50%;

    --chart-2: 160 60% 45%;

    --chart-3: 30 80% 55%;

    --chart-4: 280 65% 60%;

    --chart-5: 340 75% 55%
  }
}

@layer utilities {
  /* Focus styles for accessibility */
  .focus-ring {
    @apply focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2;
  }

  /* Common button base */
  .btn-base {
    @apply px-4 py-2 rounded-lg font-medium transition-colors focus-ring disabled:opacity-50 disabled:cursor-not-allowed;
  }

  .btn-primary {
    @apply btn-base bg-blue-600 text-white hover:bg-blue-700;
  }

  .btn-secondary {
    @apply btn-base bg-gray-200 text-gray-900 hover:bg-gray-300;
  }

  /* Form inputs */
  .input {
    @apply w-full px-3 py-2 border border-gray-300 rounded-lg focus-ring;
  }

  .label {
    @apply block text-sm font-medium text-gray-700 mb-1;
  }

  /* Card */
  .card {
    @apply bg-white rounded-lg shadow-sm border border-gray-200;
  }
}



@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}


----- app\layout.tsx -----

// src/app/layout.tsx

/**
 * Next.js 14 Root Layout
 *
 * SOLID - Single Responsibility Principle (SRP)
 * Manages global HTML structure and providers ONLY
 */

import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { SessionProvider } from "@/components/providers/SessionProvider";
import { Toaster } from "@/components/ui/sonner";
const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Basketball League Admin",
  description: "Basketball league administration portal",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <SessionProvider>
          {children}
          <Toaster />
        </SessionProvider>
      </body>
    </html>
  );
}


----- app\login\page.tsx -----

// src/app/login/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Login page orchestration ONLY
 */

"use client";

import { useState } from "react";
import { signIn } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Loader2 } from "lucide-react";

const loginSchema = z.object({
  email: z.string().email("Please enter a valid email"),
  password: z.string().min(1, "Password is required"),
});

type LoginFormData = z.infer<typeof loginSchema>;

export default function LoginPage() {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
  });

  const onSubmit = async (data: LoginFormData) => {
    setIsLoading(true);
    setError(null);

    try {
      const result = await signIn("admin-credentials", {
        email: data.email,
        password: data.password,
        redirect: false,
      });

      if (result?.error) {
        setError(result.error);
      } else {
        router.push("/admin");
        router.refresh();
      }
    } catch (err: any) {
      setError("An unexpected error occurred");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 px-4">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle className="text-2xl">Admin Login</CardTitle>
          <CardDescription>
            Enter your credentials to access the admin portal
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
            {error && (
              <div className="bg-red-50 border border-red-200 text-red-800 rounded-lg p-3 text-sm">
                {error}
              </div>
            )}

            <div>
              <Label htmlFor="email">Email</Label>
              <Input
                {...register("email")}
                id="email"
                type="email"
                placeholder="admin@example.com"
                disabled={isLoading}
              />
              {errors.email && (
                <p className="text-sm text-red-600 mt-1">
                  {errors.email.message}
                </p>
              )}
            </div>

            <div>
              <Label htmlFor="password">Password</Label>
              <Input
                {...register("password")}
                id="password"
                type="password"
                disabled={isLoading}
              />
              {errors.password && (
                <p className="text-sm text-red-600 mt-1">
                  {errors.password.message}
                </p>
              )}
            </div>

            <Button type="submit" className="w-full" disabled={isLoading}>
              {isLoading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Signing in...
                </>
              ) : (
                "Sign In"
              )}
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}


----- app\unauthorized\page.tsx -----

// src/app/unauthorized/page.tsx

/**
 * User Experience
 * Clear feedback for access denied
 */

import Link from "next/link";
import { ShieldAlert } from "lucide-react";
import { Button } from "@/components/ui/button";

export default function UnauthorizedPage() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 px-4">
      <div className="text-center">
        <ShieldAlert className="mx-auto h-12 w-12 text-red-500 mb-4" />
        <h1 className="text-2xl font-bold text-gray-900 mb-2">Access Denied</h1>
        <p className="text-gray-600 mb-6">
          You don't have permission to access this page.
        </p>
        <Button asChild>
          <Link href="/admin">Return to Dashboard</Link>
        </Button>
      </div>
    </div>
  );
}


----- components\common\EmptyState.tsx -----

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Empty state component ONLY
 */

import { LucideIcon } from "lucide-react";

interface EmptyStateProps {
  icon: LucideIcon;
  title: string;
  description?: string;
  action?: React.ReactNode;
}

export function EmptyState({
  icon: Icon,
  title,
  description,
  action,
}: EmptyStateProps) {
  return (
    <div className="flex flex-col items-center justify-center p-12 text-center">
      <Icon className="h-12 w-12 text-gray-400 mb-4" />
      <h3 className="text-lg font-semibold text-gray-900 mb-2">{title}</h3>
      {description && <p className="text-gray-600 mb-4">{description}</p>}
      {action}
    </div>
  );
}


----- components\common\ErrorState.tsx -----

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Error state component ONLY
 */

import { AlertCircle } from "lucide-react";
import { Button } from "@/components/ui/button";

interface ErrorStateProps {
  message?: string;
  onRetry?: () => void;
}

export function ErrorState({
  message = "Something went wrong",
  onRetry,
}: ErrorStateProps) {
  return (
    <div
      role="alert"
      className="flex flex-col items-center justify-center p-12 text-center"
    >
      <AlertCircle className="h-12 w-12 text-red-500 mb-4" />
      <h3 className="text-lg font-semibold mb-2">Error</h3>
      <p className="text-gray-600 mb-4">{message}</p>
      {onRetry && (
        <Button onClick={onRetry} variant="outline">
          Try Again
        </Button>
      )}
    </div>
  );
}


----- components\common\LoadingState.tsx -----

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Loading state component ONLY
 */

/**
 * Accessibility
 * Proper ARIA labels for screen readers
 */

import { Loader2 } from "lucide-react";

interface LoadingStateProps {
  message?: string;
}

export function LoadingState({ message = "Loading..." }: LoadingStateProps) {
  return (
    <div
      role="status"
      aria-live="polite"
      className="flex flex-col items-center justify-center p-12"
    >
      <Loader2 className="h-8 w-8 animate-spin text-blue-600 mb-3" />
      <p className="text-sm text-gray-600">{message}</p>
    </div>
  );
}


----- components\common\Pagination.tsx -----

// // src/components/common/Pagination.tsx
// "use client";

// import {
//   Pagination as ShadcnPagination,
//   PaginationContent,
//   PaginationItem,
//   PaginationLink,
//   PaginationNext,
//   PaginationPrevious,
//   PaginationEllipsis,
// } from "@/components/ui/pagination";

// interface PaginationProps {
//   currentPage: number;
//   totalPages: number;
//   total: number;
//   limit?: number;
//   onPageChange: (page: number) => void;
//   label?: string; // e.g., "players", "divisions"
// }

// export function Pagination({
//   currentPage,
//   totalPages,
//   total,
//   limit = 12,
//   onPageChange,
//   label = "items",
// }: PaginationProps) {
//   if (totalPages <= 1) return null;

//   const startIndex = (currentPage - 1) * limit;
//   const endIndex = Math.min(currentPage * limit, total);

//   const pages = Array.from({ length: totalPages }, (_, i) => i + 1);

//   return (
//     <div className="flex flex-col sm:flex-row items-center justify-between gap-4 bg-white rounded-lg shadow p-4">
//       {/* Showing X-Y of Z */}
//       <div className="text-sm text-gray-600">
//         Showing {startIndex + 1} to {endIndex} of {total} {label}
//       </div>

//       {/* Pagination Buttons */}
//       <ShadcnPagination>
//         <PaginationContent className="flex gap-2">
//           {/* Previous */}
//           <PaginationItem>
//             <PaginationPrevious
//               onClick={() => currentPage > 1 && onPageChange(currentPage - 1)}
//               aria-disabled={currentPage === 1}
//               className={
//                 currentPage === 1 ? "pointer-events-none opacity-50" : ""
//               }
//             >
//               Previous
//             </PaginationPrevious>
//           </PaginationItem>

//           {/* Page numbers */}
//           {pages.map((page) => {
//             if (
//               page === 1 ||
//               page === totalPages ||
//               (page >= currentPage - 1 && page <= currentPage + 1)
//             ) {
//               return (
//                 <PaginationItem key={page}>
//                   <PaginationLink
//                     isActive={currentPage === page}
//                     onClick={() => onPageChange(page)}
//                   >
//                     {page}
//                   </PaginationLink>
//                 </PaginationItem>
//               );
//             } else if (page === currentPage - 2 || page === currentPage + 2) {
//               return <PaginationEllipsis key={page} />;
//             }
//             return null;
//           })}

//           {/* Next */}
//           <PaginationItem>
//             <PaginationNext
//               onClick={() => onPageChange(currentPage + 1)}
//               aria-disabled={currentPage === totalPages}
//               className={
//                 currentPage === 1 ? "pointer-events-none opacity-50" : ""
//               }
//             >
//               Next
//             </PaginationNext>
//           </PaginationItem>
//         </PaginationContent>
//       </ShadcnPagination>
//     </div>
//   );
// }

// src/components/common/Pagination.tsx
"use client";

import {
  Pagination as ShadcnPagination,
  PaginationContent,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
  PaginationEllipsis,
} from "@/components/ui/pagination";

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  total: number;
  limit?: number;
  onPageChange: (page: number) => void;
  label?: string; // e.g., "players", "divisions"
}

export function Pagination({
  currentPage,
  totalPages,
  total,
  limit = 12,
  onPageChange,
  label = "items",
}: PaginationProps) {
  if (totalPages <= 1) return null;

  const startIndex = (currentPage - 1) * limit;
  const endIndex = Math.min(currentPage * limit, total);

  const pages = Array.from({ length: totalPages }, (_, i) => i + 1);

  // Debug info
  console.log("[Pagination] currentPage:", currentPage);
  console.log("[Pagination] totalPages:", totalPages);
  console.log("[Pagination] startIndex:", startIndex);
  console.log("[Pagination] endIndex:", endIndex);
  console.log("[Pagination] total items:", total);

  return (
    <div className="flex flex-col sm:flex-row items-center justify-between gap-4 bg-white rounded-lg shadow p-4">
      {/* Showing X-Y of Z */}
      <div className="text-sm text-gray-600">
        Showing {startIndex + 1} to {endIndex} of {total} {label}
      </div>

      {/* Pagination Buttons */}
      <ShadcnPagination>
        <PaginationContent className="flex gap-2">
          {/* Previous */}
          <PaginationItem>
            <PaginationPrevious
              onClick={() => {
                console.log("[Pagination] Previous clicked");
                if (currentPage > 1) onPageChange(currentPage - 1);
              }}
              aria-disabled={currentPage === 1}
              className={
                currentPage === 1 ? "pointer-events-none opacity-50" : ""
              }
            >
              Previous
            </PaginationPrevious>
          </PaginationItem>

          {/* Page numbers */}
          {pages.map((page) => {
            if (
              page === 1 ||
              page === totalPages ||
              (page >= currentPage - 1 && page <= currentPage + 1)
            ) {
              return (
                <PaginationItem key={page}>
                  <PaginationLink
                    isActive={currentPage === page}
                    onClick={() => {
                      console.log(`[Pagination] Page ${page} clicked`);
                      onPageChange(page);
                    }}
                  >
                    {page}
                  </PaginationLink>
                </PaginationItem>
              );
            } else if (page === currentPage - 2 || page === currentPage + 2) {
              return <PaginationEllipsis key={page} />;
            }
            return null;
          })}

          {/* Next */}
          <PaginationItem>
            <PaginationNext
              onClick={() => {
                console.log("[Pagination] Next clicked");
                if (currentPage < totalPages) onPageChange(currentPage + 1);
              }}
              aria-disabled={currentPage === totalPages}
              className={
                currentPage === totalPages
                  ? "pointer-events-none opacity-50"
                  : ""
              }
            >
              Next
            </PaginationNext>
          </PaginationItem>
        </PaginationContent>
      </ShadcnPagination>
    </div>
  );
}


----- components\features\admins\AdminsTable.tsx -----

// src/components/features/admins/AdminsTable.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Display admins table ONLY
 */

"use client";

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { format } from "date-fns";

import { IAdmin } from "@/models/Admin";

interface AdminsTableProps {
  admins: IAdmin[];
  cityId: string;
}

export function AdminsTable({ admins, cityId }: AdminsTableProps) {
  const getRoleBadgeColor = (role: string) => {
    const colors = {
      EXECUTIVE: "bg-purple-100 text-purple-800",
      COMMISSIONER: "bg-blue-100 text-blue-800",
      SCOREKEEPER: "bg-green-100 text-green-800",
      PHOTOGRAPHER: "bg-orange-100 text-orange-800",
    };
    return colors[role as keyof typeof colors] || "bg-gray-100 text-gray-800";
  };

  return (
    <div className="bg-white rounded-lg shadow">
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead>Name</TableHead>
            <TableHead>Email</TableHead>
            <TableHead>Role</TableHead>
            <TableHead>Access</TableHead>
            <TableHead>Status</TableHead>
            <TableHead>Created</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {admins.map((admin) => (
            <TableRow key={admin._id}>
              <TableCell className="font-medium">{admin.name}</TableCell>
              <TableCell>{admin.email}</TableCell>
              <TableCell>
                <Badge className={getRoleBadgeColor(admin.role)}>
                  {admin.role}
                </Badge>
              </TableCell>
              <TableCell className="text-sm text-gray-600">
                {admin.allLocations
                  ? "All Locations"
                  : `${admin.assignedLocations?.length || 0} location(s)`}
              </TableCell>
              <TableCell>
                {admin.isActive ? (
                  <Badge
                    variant="outline"
                    className="bg-green-50 text-green-700"
                  >
                    Active
                  </Badge>
                ) : (
                  <Badge variant="outline" className="bg-gray-50 text-gray-700">
                    Inactive
                  </Badge>
                )}
              </TableCell>
              <TableCell className="text-sm text-gray-600">
                {format(new Date(admin.createdAt), "MMM dd, yyyy")}
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}


----- components\features\admins\CreateAdminForm.tsx -----

// src/components/features/admins/CreateAdminForm.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Admin creation form ONLY
 */

// src/components/features/admins/CreateAdminForm.tsx

"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Checkbox } from "@/components/ui/checkbox";
import { Loader2 } from "lucide-react";
import { toast } from "sonner";
import { ILocation } from "@/models/Location";

const createAdminSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Invalid email address"),
  password: z
    .string()
    .min(8, "Password must be at least 8 characters")
    .regex(/[A-Z]/, "Must contain uppercase letter")
    .regex(/[a-z]/, "Must contain lowercase letter")
    .regex(/[0-9]/, "Must contain number"),
  phoneNumber: z.string().optional(),
});

type CreateAdminFormData = z.infer<typeof createAdminSchema>;

interface CreateAdminFormProps {
  locations: ILocation[];
  cityId: string;
}

export function CreateAdminForm({ locations, cityId }: CreateAdminFormProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [selectedRole, setSelectedRole] = useState<string>("");
  const [selectedLocations, setSelectedLocations] = useState<string[]>([]);

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<CreateAdminFormData>({
    resolver: zodResolver(createAdminSchema),
  });

  const needsLocationAssignment =
    selectedRole === "SCOREKEEPER" || selectedRole === "PHOTOGRAPHER";

  const onSubmit = async (data: CreateAdminFormData) => {
    if (!selectedRole) {
      toast.error("Please select a role");
      return;
    }

    if (needsLocationAssignment && selectedLocations.length === 0) {
      toast.error("Please select at least one location");
      return;
    }

    setIsLoading(true);

    try {
      const response = await fetch("/api/v1/admins", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          ...data,
          role: selectedRole,
          assignedLocations: needsLocationAssignment
            ? selectedLocations
            : undefined,
        }),
      });

      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.error || "Failed to create admin");
      }

      toast.success("Admin created successfully!");
      router.push(`/admin/settings/admins`);
      router.refresh();
    } catch (err: any) {
      toast.error(err.message || "Failed to create admin");
      console.error("Create admin error:", err);
    } finally {
      setIsLoading(false);
    }
  };

  const toggleLocation = (locationId: string) => {
    setSelectedLocations((prev) =>
      prev.includes(locationId)
        ? prev.filter((id) => id !== locationId)
        : [...prev, locationId]
    );
  };

  return (
    <form
      onSubmit={handleSubmit(onSubmit)}
      className="space-y-6 bg-white p-6 rounded-lg shadow"
    >
      <div className="grid gap-6 md:grid-cols-2">
        <div>
          <Label htmlFor="name">Full Name *</Label>
          <Input {...register("name")} id="name" disabled={isLoading} />
          {errors.name && (
            <p className="text-sm text-red-600 mt-1">{errors.name.message}</p>
          )}
        </div>

        <div>
          <Label htmlFor="email">Email *</Label>
          <Input
            {...register("email")}
            id="email"
            type="email"
            disabled={isLoading}
          />
          {errors.email && (
            <p className="text-sm text-red-600 mt-1">{errors.email.message}</p>
          )}
        </div>

        <div>
          <Label htmlFor="password">Password *</Label>
          <Input
            {...register("password")}
            id="password"
            type="password"
            disabled={isLoading}
          />
          {errors.password && (
            <p className="text-sm text-red-600 mt-1">
              {errors.password.message}
            </p>
          )}
        </div>

        <div>
          <Label htmlFor="phoneNumber">Phone Number</Label>
          <Input
            {...register("phoneNumber")}
            id="phoneNumber"
            disabled={isLoading}
          />
        </div>
      </div>

      <div>
        <Label htmlFor="role">Role *</Label>
        <Select
          value={selectedRole}
          onValueChange={setSelectedRole}
          disabled={isLoading}
        >
          <SelectTrigger>
            <SelectValue placeholder="Select role" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="EXECUTIVE">Executive</SelectItem>
            <SelectItem value="COMMISSIONER">Commissioner</SelectItem>
            <SelectItem value="SCOREKEEPER">Scorekeeper</SelectItem>
            <SelectItem value="PHOTOGRAPHER">Photographer</SelectItem>
          </SelectContent>
        </Select>
        {!selectedRole && (
          <p className="text-sm text-gray-600 mt-1">Please select a role</p>
        )}
        {selectedRole && (
          <p className="text-sm text-gray-600 mt-1">
            {selectedRole === "EXECUTIVE" || selectedRole === "COMMISSIONER"
              ? "Full access to all locations"
              : "Must assign specific locations"}
          </p>
        )}
      </div>

      {needsLocationAssignment && (
        <div>
          <Label>Assigned Locations *</Label>
          <div className="mt-2 space-y-2 border rounded-lg p-4 max-h-48 overflow-y-auto">
            {locations.length === 0 ? (
              <p className="text-sm text-gray-500">
                No locations available in this city
              </p>
            ) : (
              locations.map((location) => (
                <div key={location._id} className="flex items-center space-x-2">
                  <Checkbox
                    id={location._id}
                    checked={selectedLocations.includes(location._id)}
                    onCheckedChange={() => toggleLocation(location._id)}
                  />
                  <label
                    htmlFor={location._id}
                    className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer"
                  >
                    {location.name}
                  </label>
                </div>
              ))
            )}
          </div>
          {selectedLocations.length === 0 && (
            <p className="text-sm text-red-600 mt-1">
              Please select at least one location
            </p>
          )}
        </div>
      )}

      <div className="flex gap-4">
        <Button type="submit" disabled={isLoading || !selectedRole}>
          {isLoading ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              Creating...
            </>
          ) : (
            "Create Admin"
          )}
        </Button>
        <Button
          type="button"
          variant="outline"
          onClick={() => router.back()}
          disabled={isLoading}
        >
          Cancel
        </Button>
      </div>
    </form>
  );
}


----- components\features\dashboard\DashboardStats.tsx -----

// src/components/features/dashboard/DashboardStats.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Display dashboard stats ONLY
 */

"use client";

import { Card, CardContent } from "@/components/ui/card";
import { Users, Trophy, Calendar, MapPin } from "lucide-react";

interface DashboardStatsProps {
  stats: {
    divisions: number;
    teams: number;
    players: number;
    games: number;
  };
}

export function DashboardStats({ stats }: DashboardStatsProps) {
  const cards = [
    {
      label: "Active Divisions",
      value: stats.divisions,
      icon: MapPin,
      color: "text-blue-600",
    },
    {
      label: "Total Teams",
      value: stats.teams,
      icon: Trophy,
      color: "text-green-600",
    },
    {
      label: "Registered Players",
      value: stats.players,
      icon: Users,
      color: "text-purple-600",
    },
    {
      label: "Scheduled Games",
      value: stats.games,
      icon: Calendar,
      color: "text-orange-600",
    },
  ];

  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
      {cards.map((card) => (
        <Card key={card.label}>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">
                  {card.label}
                </p>
                <p className="text-3xl font-bold mt-2">{card.value}</p>
              </div>
              <card.icon className={`h-8 w-8 ${card.color}`} />
            </div>
          </CardContent>
        </Card>
      ))}
    </div>
  );
}


----- components\features\dashboard\UpcomingGames.tsx -----

// src/components/features/dashboard/UpcomingGames.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Display upcoming games ONLY
 */

"use client";

import Link from "next/link";
import { format } from "date-fns";
import { Calendar } from "lucide-react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { EmptyState } from "@/components/common/EmptyState";
import { IGame } from "@/models/Game";

interface UpcomingGamesProps {
  games: IGame[];
}

export function UpcomingGames({ games }: UpcomingGamesProps) {
  if (games.length === 0) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Upcoming Games</CardTitle>
        </CardHeader>
        <CardContent>
          <EmptyState
            icon={Calendar}
            title="No upcoming games"
            description="There are no scheduled games at the moment"
          />
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Upcoming Games</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {games.map((game) => (
            <Link
              key={game._id}
              href={`/admin/games/${game._id}`}
              className="block p-3 rounded-lg hover:bg-gray-50 transition-colors"
            >
              {/* <div className="font-medium">
                {game.homeTeam.teamName} vs {game.awayTeam.teamName}
              </div> */}
              <div className="flex items-center gap-4 mt-2 text-sm text-gray-600">
                <span>{format(new Date(game.date), "MMM dd, yyyy")}</span>
                <span>{game.time}</span>
                <Badge variant="outline">Upcoming</Badge>
              </div>
            </Link>
          ))}
        </div>
      </CardContent>
    </Card>
  );
}


----- components\features\league\cities\CitiesTable.tsx -----

// src/components/features/league/cities/CitiesTable.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Display cities table ONLY
 */

"use client";

import { useState } from "react";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { MoreHorizontal, Pencil, Trash2 } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { DeleteCityDialog } from "./DeleteCityDialog";
import { EditCityDialog } from "./EditCityDialog";
import { toast } from "sonner";
import { ICity } from "@/models/City";

interface CitiesTableProps {
  cities: ICity[];
}

export function CitiesTable({ cities }: CitiesTableProps) {
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [editDialogOpen, setEditDialogOpen] = useState(false);
  const [selectedCity, setSelectedCity] = useState<ICity | null>(null);

  const handleDelete = (city: ICity) => {
    setSelectedCity(city);
    setDeleteDialogOpen(true);
  };

  const handleEdit = (city: ICity) => {
    setSelectedCity(city);
    setEditDialogOpen(true);
  };

  const handleToggleActive = async (city: ICity) => {
    try {
      const response = await fetch("/api/v1/league/cities", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          id: city._id,
          active: !city.active,
        }),
      });

      if (!response.ok) throw new Error("Failed to update city");

      toast.success(`City ${city.active ? "deactivated" : "activated"}`);
      window.location.reload();
    } catch (error) {
      toast.error("Failed to update city status");
    }
  };

  return (
    <>
      <div className="bg-white rounded-lg shadow">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>City</TableHead>
              <TableHead>Region</TableHead>
              <TableHead>Country</TableHead>
              <TableHead>Timezone</TableHead>
              <TableHead>Locations</TableHead>
              <TableHead>Status</TableHead>
              <TableHead className="w-[70px]"></TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {cities.length === 0 ? (
              <TableRow>
                <TableCell
                  colSpan={7}
                  className="text-center py-8 text-gray-500"
                >
                  No cities found. Create your first city to get started.
                </TableCell>
              </TableRow>
            ) : (
              cities.map((city) => (
                <TableRow key={city._id}>
                  <TableCell className="font-medium">{city.cityName}</TableCell>
                  <TableCell>{city.region}</TableCell>
                  <TableCell>{city.country}</TableCell>
                  <TableCell className="text-sm text-gray-600">
                    {city.timezone}
                  </TableCell>
                  <TableCell className="text-sm text-gray-600">
                    {city.locations.length} location(s)
                  </TableCell>
                  <TableCell>
                    {city.active ? (
                      <Badge
                        variant="outline"
                        className="bg-green-50 text-green-700 border-green-200"
                      >
                        Active
                      </Badge>
                    ) : (
                      <Badge
                        variant="outline"
                        className="bg-gray-50 text-gray-700"
                      >
                        Inactive
                      </Badge>
                    )}
                  </TableCell>
                  <TableCell>
                    <DropdownMenu>
                      <DropdownMenuTrigger asChild>
                        <Button variant="ghost" size="icon">
                          <MoreHorizontal className="h-4 w-4" />
                        </Button>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="end">
                        <DropdownMenuItem onClick={() => handleEdit(city)}>
                          <Pencil className="mr-2 h-4 w-4" />
                          Edit
                        </DropdownMenuItem>
                        <DropdownMenuItem
                          onClick={() => handleToggleActive(city)}
                        >
                          {city.active ? "Deactivate" : "Activate"}
                        </DropdownMenuItem>
                        <DropdownMenuItem
                          onClick={() => handleDelete(city)}
                          className="text-red-600"
                        >
                          <Trash2 className="mr-2 h-4 w-4" />
                          Delete
                        </DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>

      {selectedCity && (
        <>
          <DeleteCityDialog
            city={selectedCity}
            open={deleteDialogOpen}
            onOpenChange={setDeleteDialogOpen}
          />
          <EditCityDialog
            city={selectedCity}
            open={editDialogOpen}
            onOpenChange={setEditDialogOpen}
          />
        </>
      )}
    </>
  );
}


----- components\features\league\cities\CreateCityForm.tsx -----

// src/components/features/league/cities/CreateCityForm.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * City creation form ONLY
 */

"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Loader2 } from "lucide-react";
import { toast } from "sonner";
import { createCitySchema, CreateCityInput } from "@/lib/validations/city";

const TIMEZONES = [
  "America/New_York",
  "America/Chicago",
  "America/Denver",
  "America/Los_Angeles",
  "America/Toronto",
  "America/Vancouver",
  "Europe/London",
  "Europe/Paris",
  "Asia/Tokyo",
  "Australia/Sydney",
];

export function CreateCityForm() {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);

  const {
    register,
    handleSubmit,
    formState: { errors },
    setValue,
    watch,
  } = useForm<CreateCityInput>({
    resolver: zodResolver(createCitySchema),
  });

  const selectedTimezone = watch("timezone");

  const onSubmit = async (data: CreateCityInput) => {
    setIsLoading(true);

    try {
      const response = await fetch("/api/v1/league/cities", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.error || "Failed to create city");
      }

      toast.success("City created successfully!");
      router.push("/admin/league/cities");
      router.refresh();
    } catch (err: any) {
      toast.error(err.message || "Failed to create city");
      console.error("Create city error:", err);
    } finally {
      setIsLoading(false);
    }
  };

  const onError = (errors: any) => {
    console.log("Form validation errors:", errors);
    toast.error("Please fill in all required fields");
  };

  return (
    <form
      onSubmit={handleSubmit(onSubmit, onError)}
      className="space-y-6 bg-white p-6 rounded-lg shadow"
    >
      <div className="grid gap-6 md:grid-cols-2">
        <div>
          <Label htmlFor="cityName">City Name *</Label>
          <Input
            {...register("cityName")}
            id="cityName"
            placeholder="Toronto"
            disabled={isLoading}
          />
          {errors.cityName && (
            <p className="text-sm text-red-600 mt-1">
              {errors.cityName.message}
            </p>
          )}
        </div>

        <div>
          <Label htmlFor="region">Region/State *</Label>
          <Input
            {...register("region")}
            id="region"
            placeholder="Ontario"
            disabled={isLoading}
          />
          {errors.region && (
            <p className="text-sm text-red-600 mt-1">{errors.region.message}</p>
          )}
        </div>

        <div>
          <Label htmlFor="country">Country *</Label>
          <Input
            {...register("country")}
            id="country"
            placeholder="Canada"
            disabled={isLoading}
          />
          {errors.country && (
            <p className="text-sm text-red-600 mt-1">
              {errors.country.message}
            </p>
          )}
        </div>

        <div>
          <Label htmlFor="timezone">Timezone *</Label>
          <Select
            value={selectedTimezone}
            onValueChange={(value) =>
              setValue("timezone", value, { shouldValidate: true })
            }
            disabled={isLoading}
          >
            <SelectTrigger>
              <SelectValue placeholder="Select timezone" />
            </SelectTrigger>
            <SelectContent>
              {TIMEZONES.map((tz) => (
                <SelectItem key={tz} value={tz}>
                  {tz}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
          {errors.timezone && (
            <p className="text-sm text-red-600 mt-1">
              {errors.timezone.message}
            </p>
          )}
        </div>
      </div>

      <div className="flex gap-4">
        <Button type="submit" disabled={isLoading}>
          {isLoading ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              Creating...
            </>
          ) : (
            "Create City"
          )}
        </Button>
        <Button
          type="button"
          variant="outline"
          onClick={() => router.back()}
          disabled={isLoading}
        >
          Cancel
        </Button>
      </div>
    </form>
  );
}


----- components\features\league\cities\DeleteCityDialog.tsx -----

// src/components/features/league/cities/DeleteCityDialog.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Delete city confirmation dialog ONLY
 */

"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import {
  AlertDialog,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";
import { Loader2 } from "lucide-react";
import { toast } from "sonner";
import { ICity } from "@/models/City";

interface DeleteCityDialogProps {
  city: ICity;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function DeleteCityDialog({
  city,
  open,
  onOpenChange,
}: DeleteCityDialogProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);

  const handleDelete = async () => {
    setIsLoading(true);

    try {
      const response = await fetch(`/api/v1/league/cities?id=${city._id}`, {
        method: "DELETE",
      });

      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.error || "Failed to delete city");
      }

      toast.success("City deleted successfully");
      onOpenChange(false);
      router.refresh();
    } catch (err: any) {
      toast.error(err.message || "Failed to delete city");
      console.error("Delete city error:", err);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <AlertDialog open={open} onOpenChange={onOpenChange}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Delete City</AlertDialogTitle>
          <AlertDialogDescription>
            Are you sure you want to delete{" "}
            <span className="font-semibold">
              {city.cityName}, {city.region}, {city.country}
            </span>
            ? This action cannot be undone.
            <br />
            <br />
            Note: Existing divisions, teams, and games will not be affected.
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <Button
            variant="outline"
            onClick={() => onOpenChange(false)}
            disabled={isLoading}
          >
            Cancel
          </Button>
          <Button
            variant="destructive"
            onClick={handleDelete}
            disabled={isLoading}
          >
            {isLoading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Deleting...
              </>
            ) : (
              "Delete City"
            )}
          </Button>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}


----- components\features\league\cities\EditCityDialog.tsx -----

// src/components/features/league/cities/EditCityDialog.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Edit city dialog ONLY
 */

"use client";

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Loader2 } from "lucide-react";
import { toast } from "sonner";
import { createCitySchema, CreateCityInput } from "@/lib/validations/city";
import { ICity } from "@/models/City";

const TIMEZONES = [
  "America/New_York",
  "America/Chicago",
  "America/Denver",
  "America/Los_Angeles",
  "America/Toronto",
  "America/Vancouver",
  "Europe/London",
  "Europe/Paris",
  "Asia/Tokyo",
  "Australia/Sydney",
];

interface EditCityDialogProps {
  city: ICity;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function EditCityDialog({
  city,
  open,
  onOpenChange,
}: EditCityDialogProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [selectedTimezone, setSelectedTimezone] = useState<string>(
    city.timezone
  );

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<CreateCityInput>({
    resolver: zodResolver(createCitySchema),
    defaultValues: {
      cityName: city.cityName,
      region: city.region,
      country: city.country,
      timezone: city.timezone,
    },
  });

  useEffect(() => {
    if (open) {
      reset({
        cityName: city.cityName,
        region: city.region,
        country: city.country,
        timezone: city.timezone,
      });
      setSelectedTimezone(city.timezone);
    }
  }, [open, city, reset]);

  const onSubmit = async (data: CreateCityInput) => {
    setIsLoading(true);

    try {
      const response = await fetch("/api/v1/league/cities", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          id: city._id,
          ...data,
          timezone: selectedTimezone,
        }),
      });

      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.error || "Failed to update city");
      }

      toast.success("City updated successfully!");
      onOpenChange(false);
      router.refresh();
    } catch (err: any) {
      toast.error(err.message || "Failed to update city");
      console.error("Update city error:", err);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Edit City</DialogTitle>
          <DialogDescription>Update city information</DialogDescription>
        </DialogHeader>

        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          <div>
            <Label htmlFor="edit-cityName">City Name *</Label>
            <Input
              {...register("cityName")}
              id="edit-cityName"
              disabled={isLoading}
            />
            {errors.cityName && (
              <p className="text-sm text-red-600 mt-1">
                {errors.cityName.message}
              </p>
            )}
          </div>

          <div>
            <Label htmlFor="edit-region">Region/State *</Label>
            <Input
              {...register("region")}
              id="edit-region"
              disabled={isLoading}
            />
            {errors.region && (
              <p className="text-sm text-red-600 mt-1">
                {errors.region.message}
              </p>
            )}
          </div>

          <div>
            <Label htmlFor="edit-country">Country *</Label>
            <Input
              {...register("country")}
              id="edit-country"
              disabled={isLoading}
            />
            {errors.country && (
              <p className="text-sm text-red-600 mt-1">
                {errors.country.message}
              </p>
            )}
          </div>

          <div>
            <Label htmlFor="edit-timezone">Timezone *</Label>
            <Select
              value={selectedTimezone}
              onValueChange={setSelectedTimezone}
              disabled={isLoading}
            >
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {TIMEZONES.map((tz) => (
                  <SelectItem key={tz} value={tz}>
                    {tz}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="flex gap-4 justify-end">
            <Button
              type="button"
              variant="outline"
              onClick={() => onOpenChange(false)}
              disabled={isLoading}
            >
              Cancel
            </Button>
            <Button type="submit" disabled={isLoading}>
              {isLoading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Saving...
                </>
              ) : (
                "Save Changes"
              )}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
