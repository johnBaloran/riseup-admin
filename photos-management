

import Navigation from "@/components/Navigation";
import Link from "next/link";
import PhotosDividedByLevelsPage from "@/components/photos/PhotosDividedByLevels";
import { useRouter } from "next/router";

// Fixed component name (was CityGamePage, should be CityPhotosPage)
const CityPhotosPage = ({
  allDivisions,
  selectedCity,
  allCities,
  allLevels,
}) => {
  const router = useRouter();

  console.log("allDivisions:", allDivisions);

  // Handle loading and error states
  if (router.isFallback) {
    return (
      <div>
        <Navigation />
        <div className="container">
          <div className="text-center text-white">Loading...</div>
        </div>
      </div>
    );
  }

  if (!selectedCity) {
    return (
      <div>
        <Navigation />
        <div className="container">
          <div className="text-center">
            <h1 className="text-2xl font-bold text-red-600">City not found</h1>
            <button
              onClick={() => router.back()}
              className="mt-4 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
            >
              Go Back
            </button>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div>
      <Navigation />
      <div className="container">
        <h1 className="text-5xl font-bold my-16 text-center text-white">
          {selectedCity.cityName} Photos
        </h1>

        <div className="w-full my-16">
          <div className="flex flex-wrap gap-2 bg-[#282D35] p-2 rounded">
            {(allCities || []).map((city) => (
              <Link
                key={city._id} // Added missing key prop
                href={`/photos/city/${city._id}`}
                className={`px-4 py-2 rounded capitalize transition-colors duration-200 
                  ${
                    selectedCity._id === city._id
                      ? "bg-red-500 text-white"
                      : "text-white hover:bg-[#363B44]"
                  }`}
              >
                {city.cityName}
              </Link>
            ))}
          </div>
        </div>

        <PhotosDividedByLevelsPage
          divisions={allDivisions || []}
          levels={allLevels || []}
        />
      </div>
    </div>
  );
};

export default CityPhotosPage; // Fixed export name

export const getServerSideProps = async (context) => {
  const { id } = context.params;
  const { req } = context;

  // Get the base URL for server-side requests
  const protocol = req.headers["x-forwarded-proto"] || "http";
  const host = req.headers.host;
  const baseUrl =
    process.env.NEXT_PUBLIC_API_BASE_URL || `${protocol}://${host}/`;

  console.log(`[getServerSideProps] Fetching photos data for city ID: ${id}`);
  console.log(`[getServerSideProps] Base URL: ${baseUrl}`);

  // Initialize response data
  const responseData = {
    allDivisions: [],
    selectedCity: null,
    allCities: [],
    allLevels: [],
  };

  // Create fetch options for better reliability
  const fetchOptions = {
    headers: {
      "Content-Type": "application/json",
      "User-Agent": "NextJS-Server",
    },
    // Add timeout to prevent hanging
    signal: AbortSignal.timeout(10000), // 10 second timeout
  };

  try {
    // Fetch all data in parallel for better performance
    const [citiesRes, divisionsRes, levelsRes] = await Promise.allSettled([
      fetch(`${baseUrl}api/cities`, fetchOptions),
      fetch(
        `${baseUrl}api/city/${id}?division=true&divisionGames=true&gamePhotos=true`,
        fetchOptions
      ),
      fetch(`${baseUrl}api/levels`, fetchOptions),
    ]);

    // Process cities data
    if (citiesRes.status === "fulfilled" && citiesRes.value.ok) {
      try {
        const dataCity = await citiesRes.value.json();

        // Better data validation and filtering
        responseData.allCities = Array.isArray(dataCity.cities)
          ? dataCity.cities.filter(
              (city) => city != null && typeof city === "object"
            )
          : [];

        // Find selected city
        responseData.selectedCity =
          responseData.allCities.find((city) => city._id === id) || null;

        console.log(
          `[getServerSideProps] Cities fetched: ${responseData.allCities.length} items`
        );
        console.log(
          `[getServerSideProps] Selected city: ${
            responseData.selectedCity?.cityName || "Not found"
          }`
        );
      } catch (parseError) {
        console.error(
          "[getServerSideProps] Error parsing cities data:",
          parseError
        );
      }
    } else {
      console.error(
        "[getServerSideProps] Failed to fetch cities:",
        citiesRes.status === "fulfilled"
          ? `${citiesRes.value.status} ${citiesRes.value.statusText}`
          : citiesRes.reason
      );
    }

    // Process divisions data
    if (divisionsRes.status === "fulfilled" && divisionsRes.value.ok) {
      try {
        const dataDivision = await divisionsRes.value.json();

        responseData.allDivisions = Array.isArray(dataDivision.divisions)
          ? dataDivision.divisions.filter(Boolean)
          : [];

        console.log(
          `[getServerSideProps] Divisions fetched: ${responseData.allDivisions.length} items`
        );
      } catch (parseError) {
        console.error(
          "[getServerSideProps] Error parsing divisions data:",
          parseError
        );
      }
    } else {
      console.error(
        "[getServerSideProps] Failed to fetch divisions:",
        divisionsRes.status === "fulfilled"
          ? `${divisionsRes.value.status} ${divisionsRes.value.statusText}`
          : divisionsRes.reason
      );
    }

    // Process levels data
    if (levelsRes.status === "fulfilled" && levelsRes.value.ok) {
      try {
        const dataLevels = await levelsRes.value.json();

        // Fixed: was using 'price' instead of 'level'
        responseData.allLevels = Array.isArray(dataLevels.levels)
          ? dataLevels.levels.filter(Boolean)
          : [];

        console.log(
          `[getServerSideProps] Levels fetched: ${responseData.allLevels.length} items`
        );
      } catch (parseError) {
        console.error(
          "[getServerSideProps] Error parsing levels data:",
          parseError
        );
      }
    } else {
      console.error(
        "[getServerSideProps] Failed to fetch levels:",
        levelsRes.status === "fulfilled"
          ? `${levelsRes.value.status} ${levelsRes.value.statusText}`
          : levelsRes.reason
      );
    }

    console.log("[getServerSideProps] Final data summary:", {
      city: responseData.selectedCity?.cityName || "Not found",
      cities: responseData.allCities.length,
      divisions: responseData.allDivisions.length,
      levels: responseData.allLevels.length,
    });

    // Return serialized data
    return {
      props: {
        allDivisions: JSON.parse(JSON.stringify(responseData.allDivisions)),
        selectedCity: responseData.selectedCity
          ? JSON.parse(JSON.stringify(responseData.selectedCity))
          : null,
        allCities: JSON.parse(JSON.stringify(responseData.allCities)),
        allLevels: JSON.parse(JSON.stringify(responseData.allLevels)),
      },
    };
  } catch (error) {
    console.error("[getServerSideProps] Critical error:", error);

    // Return safe defaults
    return {
      props: responseData,
    };
  }
};

import { convertToStandardTime } from "@/utils/convertToStandardTime";
import { useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Calendar, Clock, Upload, Image } from "lucide-react";

const DAYS = [
  "monday",
  "tuesday",
  "wednesday",
  "thursday",
  "friday",
  "saturday",
  "sunday",
];
const PHOTO_STATUSES = [
  {
    id: "hasPhotos",
    label: "Photos Available",
    icon: <Image className="w-4 h-4 mr-2" />,
  },
  {
    id: "needsPhotos",
    label: "Photos Needed",
    icon: <Upload className="w-4 h-4 mr-2" />,
  },
];

const PhotosDividedByLevelsPage = ({ divisions, levels }) => {
  const [selectedLevel, setSelectedLevel] = useState(null);
  const [selectedDay, setSelectedDay] = useState(null);
  const [selectedPhotoStatus, setSelectedPhotoStatus] = useState("needsPhotos");

  const handleLevelClick = (levelId) => {
    setSelectedLevel(levelId === selectedLevel ? null : levelId);
  };

  const handleDayClick = (day) => {
    setSelectedDay(day);
  };

  const handlePhotoStatusClick = (statusId) => {
    setSelectedPhotoStatus(statusId === selectedPhotoStatus ? null : statusId);
  };

  const filteredDivisions = divisions.filter((division) => {
    const matchesLevel = selectedLevel
      ? division.level?._id === selectedLevel
      : true;
    const matchesDay = selectedDay
      ? division.day.toLowerCase() === selectedDay.toLowerCase()
      : true;
    return matchesLevel && matchesDay;
  });

  const filteredGames = filteredDivisions.flatMap((division) =>
    division.games.filter((game) => {
      if (selectedPhotoStatus === "hasPhotos") {
        return game.status && game.gamePhotosCount >= 1;
      } else if (selectedPhotoStatus === "needsPhotos") {
        return game.status && game.gamePhotosCount === 0;
      }
      return true;
    })
  );

  return (
    <div className="min-h-screen bg-gray-50 p-6">
      <div className="max-w-7xl mx-auto space-y-8">
        {/* Filters Section */}
        <div className="bg-white rounded-xl shadow-sm p-6 space-y-6">
          <div className="grid gap-6 md:grid-cols-3">
            {/* Days Filter */}
            <div>
              <h2 className="text-xl font-semibold mb-4 text-gray-800">
                Game Days
              </h2>
              <div className="flex flex-wrap gap-2">
                {DAYS.map((day) => (
                  <button
                    key={day}
                    onClick={() => handleDayClick(day)}
                    className={`px-4 py-2 rounded-full capitalize text-sm font-medium transition-all duration-200 
                      ${
                        selectedDay === day
                          ? "bg-indigo-500 text-white shadow-md"
                          : "bg-gray-100 text-gray-600 hover:bg-gray-200"
                      }`}
                  >
                    {day}
                  </button>
                ))}
              </div>
            </div>

            {/* Levels Filter */}
            <div>
              <h2 className="text-xl font-semibold mb-4 text-gray-800">
                Levels
              </h2>
              <div className="flex flex-wrap gap-2">
                {levels.map((level) => (
                  <button
                    key={level._id}
                    onClick={() => handleLevelClick(level._id)}
                    className={`px-4 py-2 rounded-full text-sm font-medium transition-all duration-200 
                      ${
                        selectedLevel === level._id
                          ? "bg-violet-500 text-white shadow-md"
                          : "bg-gray-100 text-gray-600 hover:bg-gray-200"
                      }`}
                  >
                    {level.name}
                  </button>
                ))}
              </div>
            </div>

            {/* Photo Status Filter */}
            <div>
              <h2 className="text-xl font-semibold mb-4 text-gray-800">
                Photo Status
              </h2>
              <div className="flex flex-wrap gap-2">
                {PHOTO_STATUSES.map((status) => (
                  <button
                    key={status.id}
                    onClick={() => handlePhotoStatusClick(status.id)}
                    className={`px-4 py-2 rounded-full text-sm font-medium transition-all duration-200 flex items-center
                      ${
                        selectedPhotoStatus === status.id
                          ? "bg-teal-500 text-white shadow-md"
                          : "bg-gray-100 text-gray-600 hover:bg-gray-200"
                      }`}
                  >
                    {status.icon}
                    {status.label}
                  </button>
                ))}
              </div>
            </div>
          </div>

          {/* Active Filters */}
          {(selectedLevel || selectedDay || selectedPhotoStatus) && (
            <div className="pt-4 border-t">
              <div className="flex flex-wrap gap-2">
                {selectedDay && (
                  <Badge className="px-3 py-1 bg-indigo-100 text-indigo-600 hover:bg-indigo-200">
                    {selectedDay}
                    <button
                      onClick={() => setSelectedDay(null)}
                      className="ml-2 hover:text-indigo-800"
                    >
                      ×
                    </button>
                  </Badge>
                )}
                {selectedLevel && (
                  <Badge className="px-3 py-1 bg-violet-100 text-violet-600 hover:bg-violet-200">
                    {levels.find((l) => l._id === selectedLevel)?.name}
                    <button
                      onClick={() => setSelectedLevel(null)}
                      className="ml-2 hover:text-violet-800"
                    >
                      ×
                    </button>
                  </Badge>
                )}
                {selectedPhotoStatus && (
                  <Badge className="px-3 py-1 bg-teal-100 text-teal-600 hover:bg-teal-200">
                    {
                      PHOTO_STATUSES.find((s) => s.id === selectedPhotoStatus)
                        ?.label
                    }
                    <button
                      onClick={() => setSelectedPhotoStatus(null)}
                      className="ml-2 hover:text-teal-800"
                    >
                      ×
                    </button>
                  </Badge>
                )}
              </div>
            </div>
          )}
        </div>

        {/* Games Grid */}
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {filteredGames.map((game) => (
            <Card
              key={game._id}
              className={`overflow-hidden bg-white hover:shadow-lg transition-shadow duration-200 `}
            >
              <CardContent className="p-6">
                <div className="flex items-start justify-between">
                  <div className="space-y-4">
                    <div className="inline-flex items-center gap-2">
                      <Badge
                        variant="outline"
                        className="bg-blue-50 text-blue-600 border-blue-200"
                      >
                        Week {game.week}
                      </Badge>

                      <Badge
                        variant="outline"
                        className="bg-blue-50 text-blue-600 border-blue-200"
                      >
                        {game.division.day}
                      </Badge>

                      {game.status && (
                        <Badge className="bg-green-50 text-green-600 border-green-200">
                          Finished
                        </Badge>
                      )}
                      {game.status ? (
                        game.gamePhotosCount >= 1 ? (
                          <Badge className="bg-green-50 text-green-600 border-green-200">
                            Photos Uploaded
                          </Badge>
                        ) : (
                          <Badge className="bg-red-50 text-red-600 border-red-200">
                            Needs Photos
                          </Badge>
                        )
                      ) : (
                        ""
                      )}
                    </div>

                    <h3 className="text-lg font-semibold text-gray-800">
                      {game.gameName}
                    </h3>

                    <div className="space-y-2 text-sm text-gray-600">
                      <div className="flex items-center gap-2">
                        <span>{game.division.divisionName}</span>
                      </div>
                      <div className="flex items-center gap-2">
                        <Calendar className="h-4 w-4" />
                        <span>{new Date(game.date).toLocaleDateString()}</span>
                      </div>
                    </div>
                  </div>
                </div>

                <div className="mt-6 flex gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    className="flex-1"
                    asChild
                  >
                    <a
                      href={`/photos/${game._id}`}
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      <Upload className="w-4 h-4 mr-2" />
                      Upload Photos
                    </a>
                  </Button>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>

        {/* Empty State */}
        {filteredGames.length === 0 && (
          <div className="text-center py-12">
            <h3 className="text-lg font-medium text-gray-900">
              No games found
            </h3>
            <p className="mt-2 text-sm text-gray-500">
              Try adjusting your filters to find what you're looking for.
            </p>
          </div>
        )}
      </div>
    </div>
  );
};

export default PhotosDividedByLevelsPage;


// controllers/gamePhotoController.js

import GamePhoto from "../model/GamePhoto";
import Game from "../model/Game";

// Create a new game photo
export async function createGamePhoto(req, res) {
  try {
    const { id } = req.query;
    const { photoData } = req.body;
    const newPhoto = new GamePhoto({
      ...photoData,
      game: id,
    });

    const savedPhoto = await newPhoto.save();

    // Update the gamePhotosCount in the Game document
    await Game.findByIdAndUpdate(id, {
      $inc: { gamePhotosCount: 1 },
    });

    res.status(201).json(savedPhoto);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
}

// Get all photos for a specific game
export async function getGamePhotos(req, res) {
  try {
    const { id } = req.query;
    const photos = await GamePhoto.find({ game: id });
    res.status(200).json({ photos });
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
}

// Update a game photo
export async function updateGamePhoto(req, res) {
  try {
    const { id } = req.query;
    const { tags, isHighlight } = req.body;

    const updatedPhoto = await GamePhoto.findByIdAndUpdate(
      id,
      { tags, isHighlight },
      { new: true }
    );

    if (!updatedPhoto) {
      return res.status(404).json({ message: "Photo not found" });
    }

    res.status(200).json(updatedPhoto);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
}

// Delete a game photo
export async function deleteGamePhoto(req, res) {
  try {
    const { id } = req.query;

    console.log("id:", id);
    const deletedPhoto = await GamePhoto.findByIdAndDelete(id);

    if (!deletedPhoto) {
      return res.status(404).json({ message: "Photo not found" });
    }

    // Remove the photo reference from the game and decrease gamePhotosCount by 1
    await Game.findByIdAndUpdate(deletedPhoto.game, {
      $inc: { gamePhotosCount: -1 }, // Decrement gamePhotosCount by 1
    });
    res.status(200).json({ message: "Photo deleted successfully" });
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
}

export const getAllDivisionGamesWithPhotosByCityId = async (req, res) => {
  try {
    const divisions = await Division.find({ city: req.query.id, active: true })
      .populate({
        path: "games",
        select:
          "gameName division date time week homeTeam awayTeam homeTeamScore awayTeamScore status gamePhotosCount",
        populate: {
          path: "division",
          select: "divisionName day",
        },
      })
      .populate("level", "name grade")
      .select("divisionName  teams location level games day");

    console.log("3");

    if (divisions.length === 0) {
      return res.status(404).json({ message: "No divisions found" });
    }

    return res.status(200).json({ divisions });
  } catch (error) {
    return res.status(500).json({ error: error.message });
  }
};


import { Toaster } from "@/components/ui/toaster";
import { useToast } from "@/components/ui/use-toast";
import { useState, useEffect, useCallback, useRef } from "react";
import Navigation from "@/components/Navigation";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Checkbox } from "@/components/ui/checkbox";

const GamePhotosPage = ({
  currentGame,
  homeTeamPlayers,
  awayTeamPlayers,
  allPhotos,
}) => {
  const { toast } = useToast();
  const [uploadWidget, setUploadWidget] = useState(null);
  const [photos, setPhotos] = useState(allPhotos);
  console.log("photos:", photos);
  const [isUploading, setIsUploading] = useState(false);
  const uploadingPhotos = useRef(new Set());
  const [isDeletingPhotos, setIsDeletingPhotos] = useState(false);

  const [selectedPhotos, setSelectedPhotos] = useState([]);
  const [selectedPlayer, setSelectedPlayer] = useState("");
  const [assigningPhotos, setAssigningPhotos] = useState(false);

  // Combine and format players for the select dropdown
  const allPlayers = [
    ...homeTeamPlayers.map((player) => ({
      ...player,
      teamName: currentGame.homeTeam.teamName,
    })),
    ...awayTeamPlayers.map((player) => ({
      ...player,
      teamName: currentGame.awayTeam.teamName,
    })),
  ];

  const handlePhotoSelect = (photoId) => {
    // Find the photo to check if it's already assigned
    const photo = photos.find((p) => p.publicId === photoId);

    // If photo is already assigned to a player, prevent selection
    if (photo?.playerId) {
      toast({
        title: "Photo Already Assigned",
        className: "bg-red-600 text-white border-none",

        description: "This photo is already assigned to a player",
        variant: "destructive",
      });
      return;
    }

    setSelectedPhotos((prev) => {
      if (prev.includes(photoId)) {
        return prev.filter((id) => id !== photoId);
      }
      return [...prev, photoId];
    });
  };

  // Function to handle deleting a single photo
  const handleDeletePhoto = async (photo) => {
    if (photo.playerId) {
      toast({
        description: "Cannot delete assigned photos. Please unassign first.",
        title: "Failed!",
        className: "bg-red-600 text-white border-none",
        variant: "destructive",
      });
      return;
    }

    try {
      const response = await fetch(`/api/gamePhotos/${photo._id}`, {
        method: "DELETE",
        headers: {
          "Content-Type": "application/json",
        },
      });

      if (!response.ok) {
        throw new Error("Failed to delete photo");
      }

      // Update local state to remove the photo
      setPhotos((prevPhotos) =>
        prevPhotos.filter((p) => p.publicId !== photo.publicId)
      );

      toast({
        title: "Success!",
        className: "bg-green-600 text-white border-none",
        description: "Photo deleted successfully",
      });
    } catch (error) {
      toast({
        title: "Failed!",
        className: "bg-red-600 text-white border-none",
        variant: "destructive",
        description: "Failed to delete photo",
      });
    }
  };

  const handleUploadSuccess = useCallback(
    async (result) => {
      const publicId = result.info.public_id;

      // If this photo is already being processed, return early
      if (uploadingPhotos.current.has(publicId)) {
        return;
      }

      try {
        setIsUploading(true);
        // Add this photo to the processing set
        uploadingPhotos.current.add(publicId);

        const photoData = {
          publicId: result.info.public_id,
          url: result.info.secure_url,
          thumbnail: result.info.thumbnail_url,
          game: currentGame._id,
          tags: result.info.tags,
          isHighlight: false,
          uploadedAt: new Date(),
        };

        // Check if this photo is already in the state
        const isDuplicate = photos.some((photo) => photo.publicId === publicId);
        if (isDuplicate) {
          console.log("Duplicate photo detected:", publicId);
          return;
        }

        console.log("Uploading photo:", photoData);

        const response = await fetch(`/api/gamePhotos/${currentGame._id}`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ photoData }),
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || "Failed to save photo");
        }

        setPhotos((prevPhotos) => {
          // Double check for duplicates before updating state
          if (prevPhotos.some((photo) => photo.publicId === publicId)) {
            return prevPhotos;
          }
          return [...prevPhotos, photoData];
        });

        toast({
          title: "Success!",
          description: "Photo uploaded successfully",
          className: "bg-green-600 text-white border-none",

          duration: 3000,
        });
      } catch (err) {
        console.error("Upload error:", err);
        toast({
          title: "Error",
          description: err.message || "Failed to upload photo",
          variant: "destructive",
          className: "bg-red-600 text-white border-none",

          duration: 5000,
        });
      } finally {
        // Remove this photo from the processing set
        uploadingPhotos.current.delete(publicId);
        // Only set uploading to false if no more photos are being processed
        if (uploadingPhotos.current.size === 0) {
          setIsUploading(false);
        }
      }
    },
    [currentGame._id, toast, photos]
  );

  const initializeWidget = useCallback(() => {
    if (typeof window !== "undefined" && !uploadWidget) {
      const widget = window.cloudinary.createUploadWidget(
        {
          cloudName: process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME,
          uploadPreset: process.env.NEXT_PUBLIC_CLOUDINARY_UPLOAD_PRESET,
          folder: `game-photos/${currentGame._id}`,
          multiple: true,
          maxFiles: 300,
          resourceType: "image",
          clientAllowedFormats: ["png", "jpg", "jpeg", "webp"],
          maxFileSize: 10000000, // 10MB
          tags: [
            `game-${currentGame._id}`,
            currentGame.homeTeam.teamName,
            currentGame.awayTeam.teamName,
            new Date(currentGame.date).toISOString().split("T")[0],
          ].map((tag) => tag.toString().replace(/\s+/g, "_").toLowerCase()),
          transformation: [
            { quality: "auto:best", fetch_format: "auto", format: "webp" },
          ],
          styles: {
            palette: {
              window: "#FFFFFF",
              windowBorder: "#90A0B3",
              tabIcon: "#0078FF",
              menuIcons: "#5A616A",
              textDark: "#000000",
              textLight: "#FFFFFF",
              link: "#0078FF",
              action: "#FF620C",
              inactiveTabIcon: "#0E2F5A",
              error: "#F44235",
              inProgress: "#0078FF",
              complete: "#20B832",
              sourceBg: "#E4EBF1",
            },
          },
          sources: ["local", "camera"],
          showUploadMoreButton: true,
          singleUploadAutoClose: false,
          showCompletedButton: true,
          showSkipCropButton: false,
          croppingAspectRatio: null,
          croppingDefaultSelectionRatio: 0.8,
          language: "en",
          text: {
            en: {
              upload: "Upload Game Photos",
              processing: "Processing...",
              uploading: "Uploading...",
              complete: "Upload Complete",
              done: "Done",
            },
          },
        },
        (error, result) => {
          if (error) {
            console.error("Widget error:", error);
            toast({
              title: "Upload Error",
              description: error.message || "Error initializing upload",
              variant: "destructive",
              className: "bg-red-600 text-white border-none",

              duration: 5000,
            });
            return;
          }

          if (result?.event === "success") {
            handleUploadSuccess(result);
          }
        }
      );
      setUploadWidget(widget);
    }
  }, [currentGame._id, handleUploadSuccess, toast, uploadWidget]);

  useEffect(() => {
    const script = document.createElement("script");
    script.src = "https://upload-widget.cloudinary.com/global/all.js";
    script.async = true;
    script.onload = initializeWidget;
    document.body.appendChild(script);

    return () => {
      if (script.parentNode) {
        script.parentNode.removeChild(script);
      }
    };
  }, [initializeWidget]);

  const handleUploadClick = useCallback(() => {
    if (isUploading) {
      return;
    }

    if (!uploadWidget) {
      toast({
        title: "Error",
        description: "Upload widget is not ready. Please try again.",
        variant: "destructive",
        className: "bg-red-600 text-white border-none",

        duration: 3000,
      });
      return;
    }

    uploadWidget.open();
  }, [isUploading, uploadWidget, toast]);

  const formatGameDate = (dateString) => {
    return new Date(dateString).toLocaleDateString("en-US", {
      weekday: "long",
      year: "numeric",
      month: "long",
      day: "numeric",
    });
  };

  return (
    <div className="min-h-screen bg-[#1B1E23]">
      <Navigation />

      <div className="container mx-auto px-4 py-8">
        <div className="bg-[#282D35] rounded-lg p-6 mb-8">
          <h1 className="text-3xl font-bold text-white mb-2">
            {currentGame.gameName}
          </h1>
          <div className="text-gray-300 space-y-1">
            <p>Date: {formatGameDate(currentGame.date)}</p>
            <p>Location: {currentGame.location}</p>
            <p>
              Final Score: {currentGame.homeTeamScore} -{" "}
              {currentGame.awayTeamScore}
            </p>
          </div>
        </div>

        <div className="mb-8 w-full flex items-center justify-center">
          <button
            onClick={handleUploadClick}
            disabled={isUploading}
            className={`px-6 py-3 rounded-lg transition-all duration-200 flex items-center gap-2
              ${
                isUploading
                  ? "bg-gray-500 cursor-not-allowed"
                  : "bg-blue-600 hover:bg-blue-700"
              } 
              text-white`}
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              className={`h-5 w-5 ${isUploading ? "animate-spin" : ""}`}
              viewBox="0 0 20 20"
              fill="currentColor"
            >
              {isUploading ? (
                <path
                  fillRule="evenodd"
                  d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z"
                  clipRule="evenodd"
                />
              ) : (
                <path
                  fillRule="evenodd"
                  d="M4 5a2 2 0 00-2 2v8a2 2 0 002 2h12a2 2 0 002-2V7a2 2 0 00-2-2h-1.586a1 1 0 01-.707-.293l-1.121-1.121A2 2 0 0011.172 3H8.828a2 2 0 00-1.414.586L6.293 4.707A1 1 0 015.586 5H4zm6 9a3 3 0 100-6 3 3 0 000 6z"
                  clipRule="evenodd"
                />
              )}
            </svg>
            {isUploading ? "Uploading..." : "Upload Game Photos"}
          </button>
        </div>

        {/* Photo Grid */}
        <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
          {photos.map((photo) => (
            <div
              key={photo.publicId}
              className={`relative aspect-square rounded-lg overflow-hidden bg-[#282D35] group 
        ${selectedPhotos.includes(photo.publicId) ? "ring-2 ring-blue-500" : ""}
        ${photo.playerId ? "cursor-not-allowed opacity-90" : "cursor-pointer"}`}
              onClick={() =>
                !photo.playerId && handlePhotoSelect(photo.publicId)
              }
            >
              {/* Checkbox - only show if photo is not assigned */}
              {/* Player Tag with Unassign Button */}
              {photo.playerId && (
                <div className="absolute top-2 left-2 right-2 z-10 flex items-center justify-between gap-2">
                  <div className="px-3 py-1 bg-green-600/80 backdrop-blur-sm rounded-full text-xs text-white flex items-center gap-2">
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      className="h-4 w-4"
                      viewBox="0 0 20 20"
                      fill="currentColor"
                    >
                      <path
                        fillRule="evenodd"
                        d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z"
                        clipRule="evenodd"
                      />
                    </svg>
                    {allPlayers.find((p) => p._id === photo.playerId)
                      ?.playerName || "Unknown Player"}
                  </div>
                </div>
              )}
              <img
                src={photo.url.replace(/\.(jpg|jpeg|png)$/, ".webp")}
                alt={`Game photo`}
                className="object-cover w-full h-full transition-transform duration-200 group-hover:scale-105"
              />
              <div className="absolute bottom-0 left-0 right-0 bg-black/50 backdrop-blur-sm text-white p-2 text-sm">
                {new Date(photo.uploadedAt).toLocaleDateString()}
              </div>

              {!photo.playerId && (
                <div className="absolute top-2 right-2 z-10">
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      handleDeletePhoto(photo);
                    }}
                    className="p-1.5 bg-red-500/80 hover:bg-red-600/80 backdrop-blur-sm rounded-full 
        transition-colors duration-200 flex items-center justify-center"
                    title="Delete photo"
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      className="h-4 w-4 text-white"
                      viewBox="0 0 20 20"
                      fill="currentColor"
                    >
                      <path
                        fillRule="evenodd"
                        d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z"
                        clipRule="evenodd"
                      />
                    </svg>
                  </button>
                </div>
              )}
            </div>
          ))}
        </div>
      </div>

      <Toaster />
    </div>
  );
};

export default GamePhotosPage;

export const getServerSideProps = async (context) => {
  const { id } = context.params;

  let allPhotos = [];
  try {
    const resGames = await fetch(
      `${process.env.NEXT_PUBLIC_API_BASE_URL}api/game/${id}`
    );
    const dataGame = await resGames.json();
    const currentGame = dataGame.game;

    const homeTeamPlayers = currentGame.homeTeam.players.map((player) => ({
      ...player,
      teamId: currentGame.homeTeam._id,
    }));

    const awayTeamPlayers = currentGame.awayTeam.players.map((player) => ({
      ...player,
      teamId: currentGame.awayTeam._id,
    }));

    // Get locations data
    try {
      const resPhotos = await fetch(
        `${process.env.NEXT_PUBLIC_API_BASE_URL}api/gamePhotos/${currentGame._id}`
      );

      if (resPhotos.ok) {
        const { photos } = await resPhotos.json();
        allPhotos = photos?.map((photo) => photo || null).filter(Boolean) || [];
      } else {
        console.error("Failed to fetch photos data");
      }
    } catch (photosError) {
      console.error("Error fetching photos:", photosError);
    }
    return {
      props: {
        currentGame,
        homeTeamPlayers,
        awayTeamPlayers,
        allPhotos,
      },
    };
  } catch (error) {
    console.log(error);
    return {
      props: {
        currentGame: null,
        homeTeamPlayers: null,
        awayTeamPlayers: null,
        allPhotos: [],
      },
    };
  }
};

import mongoose from "mongoose";

import { connectToDatabase } from "@/api-helpers/utils";
import {
  createGamePhoto,
  getGamePhotos,
  updateGamePhoto,
  deleteGamePhoto,
  createManyGamePhotos,
} from "@/api-helpers/controller/game-photos-controller";

export default async function handler(req, res) {
  try {
    await connectToDatabase();

    switch (req.method) {
      case "GET":
        return getGamePhotos(req, res);
      case "POST":
        return createGamePhoto(req, res);
      case "PUT":
        return updateGamePhoto(req, res);
      case "DELETE":
        return deleteGamePhoto(req, res);
      default:
        res.status(405).json({ message: "Method Not Allowed" });
    }
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
}

// controllers/gamePhotoController.js

import GamePhoto from "../model/GamePhoto";
import Game from "../model/Game";

// Create a new game photo
export async function createGamePhoto(req, res) {
  try {
    const { id } = req.query;
    const { photoData } = req.body;
    const newPhoto = new GamePhoto({
      ...photoData,
      game: id,
    });

    const savedPhoto = await newPhoto.save();

    // Update the gamePhotosCount in the Game document
    await Game.findByIdAndUpdate(id, {
      $inc: { gamePhotosCount: 1 },
    });

    res.status(201).json(savedPhoto);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
}

// Get all photos for a specific game
export async function getGamePhotos(req, res) {
  try {
    const { id } = req.query;
    const photos = await GamePhoto.find({ game: id });
    res.status(200).json({ photos });
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
}

// Update a game photo
export async function updateGamePhoto(req, res) {
  try {
    const { id } = req.query;
    const { tags, isHighlight } = req.body;

    const updatedPhoto = await GamePhoto.findByIdAndUpdate(
      id,
      { tags, isHighlight },
      { new: true }
    );

    if (!updatedPhoto) {
      return res.status(404).json({ message: "Photo not found" });
    }

    res.status(200).json(updatedPhoto);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
}

// Delete a game photo
export async function deleteGamePhoto(req, res) {
  try {
    const { id } = req.query;

    console.log("id:", id);
    const deletedPhoto = await GamePhoto.findByIdAndDelete(id);

    if (!deletedPhoto) {
      return res.status(404).json({ message: "Photo not found" });
    }

    // Remove the photo reference from the game and decrease gamePhotosCount by 1
    await Game.findByIdAndUpdate(deletedPhoto.game, {
      $inc: { gamePhotosCount: -1 }, // Decrement gamePhotosCount by 1
    });
    res.status(200).json({ message: "Photo deleted successfully" });
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
}


import { connectToDatabase } from "@/api-helpers/utils";
import Player from "@/api-helpers/model/Player";
import Game from "@/api-helpers/model/Game";

export default async function handler(req, res) {
  if (req.method === "POST") {
    try {
      await connectToDatabase();
      const { playerId } = req.query;
      const { photos } = req.body;

      if (!photos || !Array.isArray(photos)) {
        return res.status(400).json({ message: "Invalid photos data" });
      }

      // Find the player
      const player = await Player.findById(playerId);
      if (!player) {
        return res.status(404).json({ message: "Player not found" });
      }

      // Get the game ID from the first photo
      const gameId = photos[0].gameId;
      const game = await Game.findById(gameId);
      if (!game) {
        return res.status(404).json({ message: "Game not found" });
      }

      // Ensure gamePhotos arrays exist
      if (!player.gamePhotos) {
        player.gamePhotos = [];
      }

      // Filter out photos that already exist in player's photos
      const newPhotos = photos.filter((photo) => {
        return !player.gamePhotos.some(
          (existingPhoto) => existingPhoto.publicId === photo.publicId
        );
      });

      // Add new photos to player's gamePhotos array
      if (newPhotos.length > 0) {
        player.gamePhotos = [...player.gamePhotos, ...newPhotos];
        await player.save();
      }

      // Update the game's photos to include the player reference
      if (game.gamePhotos && Array.isArray(game.gamePhotos)) {
        let hasUpdates = false;
        game.gamePhotos = game.gamePhotos.map((gamePhoto) => {
          const matchingPhoto = photos.find(
            (p) => p.publicId === gamePhoto.publicId
          );
          if (matchingPhoto) {
            hasUpdates = true;
            return {
              ...gamePhoto,
              playerId: playerId,
            };
          }
          return gamePhoto;
        });

        if (hasUpdates) {
          await game.save();
        }
      }

      return res.status(200).json({
        success: true,
        message: `${newPhotos.length} photos assigned to player`,
      });
    } catch (error) {
      console.error("Error assigning photos:", error);
      return res.status(500).json({
        message: "Error assigning photos to player",
        error: error.message,
      });
    }
  }
  if (req.method === "PATCH") {
    if (req.query.unassign === "true") {
      try {
        await connectToDatabase();
        const { playerId } = req.query;
        const { photoId, gameId } = req.body;

        if (!playerId || !photoId || !gameId) {
          return res.status(400).json({ message: "Invalid data" });
        }

        // Update the game document
        const game = await Game.findOneAndUpdate(
          {
            _id: gameId,
            "gamePhotos.publicId": photoId,
          },
          {
            $set: { "gamePhotos.$.playerId": null },
          },
          { new: true }
        );

        if (!game) {
          return res.status(404).json({ message: "Game or photo not found" });
        }

        // Update the player document
        await Player.findByIdAndUpdate(playerId, {
          $pull: {
            gamePhotos: { publicId: photoId },
          },
        });

        return res.status(200).json({
          success: true,
          message: "Photo unassigned successfully",
        });
      } catch (error) {
        console.error("Error unassigning photo:", error);
        return res.status(500).json({
          message: "Error unassigning photo",
          error: error.message,
        });
      }
    }
  }
}



