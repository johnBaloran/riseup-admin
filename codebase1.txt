

----- app\admin\page.tsx -----

// src/app/(admin)/admin/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Redirects to city-specific dashboard
 */

import { redirect } from "next/navigation";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { getActiveCities } from "@/lib/db/queries/cities";

export default async function AdminPage() {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  // Fetch active cities
  const cities = await getActiveCities();

  // No cities - show message
  if (cities.length === 0) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="text-center">
          <h1 className="text-2xl font-bold text-gray-900 mb-4">
            No Cities Configured
          </h1>
          <p className="text-gray-600">
            Please contact an administrator to set up cities.
          </p>
        </div>
      </div>
    );
  }

  // Redirect to first city's dashboard
  redirect(`/admin/${cities[0]._id}/dashboard`);
}


----- app\admin\[cityId]\dashboard\page.tsx -----

// src/app/(admin)/[cityId]/dashboard/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Dashboard page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import {
  getDashboardStats,
  getUpcomingGames,
} from "@/lib/db/queries/dashboard";
import { DashboardStats } from "@/components/features/dashboard/DashboardStats";
import { UpcomingGames } from "@/components/features/dashboard/UpcomingGames";

interface DashboardPageProps {
  params: { cityId: string };
}

export default async function DashboardPage({ params }: DashboardPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  // Get accessible location IDs
  const locationIds = session.user.allLocations
    ? []
    : session.user.assignedLocations;

  // Fetch data in parallel
  const [stats, upcomingGames] = await Promise.all([
    getDashboardStats(params.cityId, locationIds),
    getUpcomingGames(params.cityId, locationIds),
  ]);

  return (
    <div className="p-6 space-y-8">
      <div>
        <h1 className="text-3xl font-bold tracking-tight">Dashboard</h1>
        <p className="text-gray-600 mt-1">Overview of your basketball league</p>
      </div>

      <DashboardStats stats={stats} />

      <div className="grid gap-6 md:grid-cols-2">
        <UpcomingGames games={upcomingGames} cityId={params.cityId} />
      </div>
    </div>
  );
}


----- app\admin\[cityId]\layout.tsx -----

// src/app/(admin)/[cityId]/layout.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Admin section auth check and layout wrapper ONLY
 */

import { redirect } from "next/navigation";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { AdminLayout } from "@/components/layout/AdminLayout";

interface AdminLayoutWrapperProps {
  children: React.ReactNode;
  params: { cityId: string };
}

export default async function AdminLayoutWrapper({
  children,
  params,
}: AdminLayoutWrapperProps) {
  // Server-side auth check
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  return <AdminLayout cityId={params.cityId}>{children}</AdminLayout>;
}


----- app\admin\[cityId]\league\cities\new\page.tsx -----

// src/app/admin/[cityId]/league/cities/new/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Create city page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { CreateCityForm } from "@/components/features/league/cities/CreateCityForm";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";

interface CreateCityPageProps {
  params: { cityId: string };
}

export default async function CreateCityPage({ params }: CreateCityPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "manage_cities")) {
    redirect("/unauthorized");
  }

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center gap-4">
        <Button variant="ghost" size="sm" asChild>
          <Link href={`/admin/${params.cityId}/league/cities`}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back
          </Link>
        </Button>
      </div>

      <div>
        <h1 className="text-3xl font-bold tracking-tight">Add City</h1>
        <p className="text-gray-600 mt-1">
          Create a new city for league operations
        </p>
      </div>

      <div className="max-w-2xl">
        <CreateCityForm cityId={params.cityId} />
      </div>
    </div>
  );
}


----- app\admin\[cityId]\league\cities\page.tsx -----

// src/app/admin/[cityId]/league/cities/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Cities list page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getAllCities } from "@/lib/db/queries/cities";
import { CitiesTable } from "@/components/features/league/cities/CitiesTable";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Plus } from "lucide-react";

interface CitiesPageProps {
  params: { cityId: string };
}

export default async function CitiesPage({ params }: CitiesPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "manage_cities")) {
    redirect("/unauthorized");
  }

  const cities = await getAllCities();
console.log("cities:",cities)
  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">Cities</h1>
          <p className="text-gray-600 mt-1">
            Manage cities and geographic locations
          </p>
        </div>
        <Button asChild>
          <Link href={`/admin/${params.cityId}/league/cities/new`}>
            <Plus className="mr-2 h-4 w-4" />
            Add City
          </Link>
        </Button>
      </div>

      <CitiesTable cities={cities} cityId={params.cityId} />
    </div>
  );
}


----- app\admin\[cityId]\league\divisions\new\page.tsx -----

// src/app/admin/[cityId]/league/divisions/new/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Create division page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getActiveCities } from "@/lib/db/queries/cities";
import { getLocationsByCity } from "@/lib/db/queries/locations";
import { getAllLevels } from "@/lib/db/queries/levels";
import { getAllPrices } from "@/lib/db/queries/prices";
import { CreateDivisionForm } from "@/components/features/league/divisions/CreateDivisionForm";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";

interface CreateDivisionPageProps {
  params: { cityId: string };
}

export default async function CreateDivisionPage({
  params,
}: CreateDivisionPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "manage_divisions")) {
    redirect("/unauthorized");
  }

  const [cities, levels, prices] = await Promise.all([
    getActiveCities(),
    getAllLevels(),
    getAllPrices(),
  ]);

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center gap-4">
        <Button variant="ghost" size="sm" asChild>
          <Link href={`/admin/${params.cityId}/league/divisions`}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back
          </Link>
        </Button>
      </div>

      <div>
        <h1 className="text-3xl font-bold tracking-tight">Create Division</h1>
        <p className="text-gray-600 mt-1">
          Set up a new division with schedule, pricing, and registration
          settings
        </p>
      </div>

      <div className="max-w-4xl">
        <CreateDivisionForm
          cityId={params.cityId}
          cities={cities}
          levels={levels}
          prices={prices}
        />
      </div>
    </div>
  );
}


----- app\admin\[cityId]\league\divisions\page.tsx -----

// src/app/admin/[cityId]/league/divisions/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Divisions list page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getDivisions } from "@/lib/db/queries/divisions";
import { getLocationsByCity } from "@/lib/db/queries/locations";
import { getAllLevels } from "@/lib/db/queries/levels";
import { DivisionsContent } from "@/components/features/league/divisions/DivisionsContent";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Plus } from "lucide-react";

interface DivisionsPageProps {
  params: { cityId: string };
  searchParams: {
    page?: string;
    tab?: string;
    location?: string;
    level?: string;
    day?: string;
    search?: string;
  };
}

export default async function DivisionsPage({
  params,
  searchParams,
}: DivisionsPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "view_divisions")) {
    redirect("/unauthorized");
  }

  const page = parseInt(searchParams.page || "1");
  const tab = (searchParams.tab || "all") as any;

  const [result, locations, levels] = await Promise.all([
    getDivisions({
      cityId: params.cityId,
      page,
      activeFilter: tab,
      locationId: searchParams.location,
      levelId: searchParams.level,
      day: searchParams.day,
      search: searchParams.search,
    }),
    getLocationsByCity(params.cityId),
    getAllLevels(),
  ]);

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">Divisions</h1>
          <p className="text-gray-600 mt-1">
            Manage league divisions, schedules, and registration
          </p>
        </div>
        <Button asChild>
          <Link href={`/admin/${params.cityId}/league/divisions/new`}>
            <Plus className="mr-2 h-4 w-4" />
            Create Division
          </Link>
        </Button>
      </div>

      <DivisionsContent
        divisions={result.divisions}
        pagination={result.pagination}
        locations={locations}
        levels={levels}
        cityId={params.cityId}
        currentTab={tab}
        currentFilters={{
          location: searchParams.location,
          level: searchParams.level,
          day: searchParams.day,
          search: searchParams.search,
        }}
      />
    </div>
  );
}


----- app\admin\[cityId]\league\divisions\[id]\edit\page.tsx -----

// src/app/admin/[cityId]/league/divisions/[id]/edit/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Edit division page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getDivisionById } from "@/lib/db/queries/divisions";
import { getActiveCities } from "@/lib/db/queries/cities";
import { getAllLevels } from "@/lib/db/queries/levels";
import { EditDivisionForm } from "@/components/features/league/divisions/EditDivisionForm";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";

interface EditDivisionPageProps {
  params: { cityId: string; id: string };
}

export default async function EditDivisionPage({
  params,
}: EditDivisionPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "manage_divisions")) {
    redirect("/unauthorized");
  }

  const [division, cities, levels] = await Promise.all([
    getDivisionById(params.id),
    getActiveCities(),
    getAllLevels(),
  ]);

  if (!division) {
    redirect(`/admin/${params.cityId}/league/divisions`);
  }

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center gap-4">
        <Button variant="ghost" size="sm" asChild>
          <Link href={`/admin/${params.cityId}/league/divisions`}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back
          </Link>
        </Button>
      </div>

      <div>
        <h1 className="text-3xl font-bold tracking-tight">Edit Division</h1>
        <p className="text-gray-600 mt-1">
          Update division settings (pricing cannot be changed)
        </p>
      </div>

      <div className="max-w-4xl">
        <EditDivisionForm
          division={division}
          cityId={params.cityId}
          cities={cities}
          levels={levels}
        />
      </div>
    </div>
  );
}


----- app\admin\[cityId]\league\divisions\[id]\page.tsx -----

// src/app/admin/[cityId]/league/divisions/[id]/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Division detail page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import {
  getDivisionById,
  getDivisionTeamCount,
} from "@/lib/db/queries/divisions";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import Link from "next/link";
import {
  ArrowLeft,
  Pencil,
  MapPin,
  TrendingUp,
  Calendar,
  Clock,
  DollarSign,
  Users,
} from "lucide-react";
import { format, subDays } from "date-fns";
import { formatTimeRange } from "@/lib/utils/time";

interface DivisionDetailPageProps {
  params: { cityId: string; id: string };
}

export default async function DivisionDetailPage({
  params,
}: DivisionDetailPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "view_divisions")) {
    redirect("/unauthorized");
  }

  const [division, teamCount] = await Promise.all([
    getDivisionById(params.id),
    getDivisionTeamCount(params.id),
  ]);

  if (!division) {
    redirect(`/admin/${params.cityId}/league/divisions`);
  }

  const getStatusBadge = () => {
    if (!division.active && !division.register) {
      return (
        <Badge
          variant="outline"
          className="bg-gray-100 text-gray-800 border-gray-200"
        >
          Finished
        </Badge>
      );
    }
    if (!division.active && division.register) {
      return (
        <Badge
          variant="outline"
          className="bg-yellow-100 text-yellow-800 border-yellow-200"
        >
          Registration
        </Badge>
      );
    }
    if (division.active && !division.register) {
      return (
        <Badge
          variant="outline"
          className="bg-green-100 text-green-800 border-green-200"
        >
          Active - Closed
        </Badge>
      );
    }
    if (division.active && division.register) {
      return (
        <Badge
          variant="outline"
          className="bg-blue-100 text-blue-800 border-blue-200"
        >
          Active - Open
        </Badge>
      );
    }
  };

  const earlyBirdEndDate = division.startDate
    ? subDays(new Date(division.startDate), 42)
    : null;
  const isEarlyBirdActive = earlyBirdEndDate
    ? new Date() < earlyBirdEndDate
    : false;

  return (
    <div className="p-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4">
          <Button variant="ghost" size="sm" asChild>
            <Link href={`/admin/${params.cityId}/league/divisions`}>
              <ArrowLeft className="h-4 w-4 mr-2" />
              Back
            </Link>
          </Button>
        </div>
        <Button asChild>
          <Link
            href={`/admin/${params.cityId}/league/divisions/${params.id}/edit`}
          >
            <Pencil className="mr-2 h-4 w-4" />
            Edit Division
          </Link>
        </Button>
      </div>

      {/* Title & Status */}
      <div>
        <div className="flex items-center gap-3 mb-2">
          <h1 className="text-3xl font-bold tracking-tight">
            {division.divisionName}
          </h1>
          {getStatusBadge()}
        </div>
        <p className="text-gray-600">{division.description}</p>
      </div>

      <div className="grid gap-6 md:grid-cols-2">
        {/* Basic Information */}
        <Card>
          <CardHeader>
            <CardTitle>Division Details</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center gap-3">
              <MapPin className="h-5 w-5 text-gray-400" />
              <div>
                <p className="text-sm text-gray-500">Location</p>
                <p className="font-medium">
                  {division.location?.name || "N/A"}
                </p>
              </div>
            </div>

            <div className="flex items-center gap-3">
              <TrendingUp className="h-5 w-5 text-gray-400" />
              <div>
                <p className="text-sm text-gray-500">Skill Level</p>
                <p className="font-medium">
                  Grade {division.level?.grade} - {division.level?.name}
                </p>
              </div>
            </div>

            <div className="flex items-center gap-3">
              <Calendar className="h-5 w-5 text-gray-400" />
              <div>
                <p className="text-sm text-gray-500">Schedule</p>
                <p className="font-medium">
                  {division.day}{" "}
                  {formatTimeRange(division.startTime, division.endTime)}
                </p>{" "}
              </div>
            </div>

            {division.startTime && division.endTime && (
              <div className="flex items-center gap-3">
                <Clock className="h-5 w-5 text-gray-400" />
                <div>
                  <p className="text-sm text-gray-500">Time</p>
                  <p className="font-medium">
                    {division.startTime} - {division.endTime}
                  </p>
                </div>
              </div>
            )}

            {division.startDate && (
              <div className="flex items-center gap-3">
                <Calendar className="h-5 w-5 text-gray-400" />
                <div>
                  <p className="text-sm text-gray-500">Start Date</p>
                  <p className="font-medium">
                    {format(new Date(division.startDate), "MMMM dd, yyyy")}
                  </p>
                </div>
              </div>
            )}

            <div className="flex items-center gap-3">
              <Users className="h-5 w-5 text-gray-400" />
              <div>
                <p className="text-sm text-gray-500">Teams</p>
                <p className="font-medium">
                  {teamCount} team{teamCount !== 1 ? "s" : ""}
                </p>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Pricing */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <DollarSign className="h-5 w-5" />
              Pricing
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            {earlyBirdEndDate && (
              <div
                className={`p-3 rounded-lg border ${
                  isEarlyBirdActive
                    ? "bg-green-50 border-green-200"
                    : "bg-gray-50 border-gray-200"
                }`}
              >
                <p className="text-sm font-medium">
                  {isEarlyBirdActive
                    ? "✓ Early Bird Active"
                    : "Early Bird Ended"}
                </p>
                <p className="text-xs text-gray-600 mt-1">
                  {isEarlyBirdActive
                    ? `Ends ${format(earlyBirdEndDate, "MMM dd, yyyy")}`
                    : `Ended ${format(earlyBirdEndDate, "MMM dd, yyyy")}`}
                </p>
              </div>
            )}

            <div className="space-y-3">
              <div className="border-b pb-2">
                <p className="text-sm font-medium mb-2">Single Payment</p>
                <div className="grid grid-cols-2 gap-2 text-sm">
                  <div>
                    <span className="text-gray-500">Early Bird:</span>
                    <p className="font-medium">
                      $
                      {division.prices?.earlyBird?.amount?.toFixed(2) || "0.00"}
                    </p>
                  </div>
                  <div>
                    <span className="text-gray-500">Regular:</span>
                    <p className="font-medium">
                      ${division.prices?.regular?.amount?.toFixed(2) || "0.00"}
                    </p>
                  </div>
                </div>
              </div>

              <div className="border-b pb-2">
                <p className="text-sm font-medium mb-2">Installment Payments</p>
                <div className="space-y-2 text-sm">
                  <div>
                    <span className="text-gray-500">Down Payment:</span>
                    <p className="font-medium">
                      $
                      {division.prices?.firstInstallment?.amount?.toFixed(2) ||
                        "0.00"}
                    </p>
                  </div>
                  <div className="grid grid-cols-2 gap-2">
                    <div>
                      <span className="text-gray-500">Weekly (EB):</span>
                      <p className="font-medium">
                        $
                        {division.prices?.installment?.amount?.toFixed(2) ||
                          "0.00"}
                        /wk
                      </p>
                    </div>
                    <div>
                      <span className="text-gray-500">Weekly (Reg):</span>
                      <p className="font-medium">
                        $
                        {division.prices?.regularInstallment?.amount?.toFixed(
                          2
                        ) || "0.00"}
                        /wk
                      </p>
                    </div>
                  </div>
                </div>
              </div>

              <div>
                <span className="text-sm text-gray-500">Free:</span>
                <p className="font-medium text-sm">
                  ${division.prices?.free?.amount?.toFixed(2) || "0.00"}
                </p>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Quick Actions */}
      <Card>
        <CardHeader>
          <CardTitle>Quick Actions</CardTitle>
        </CardHeader>
        <CardContent className="flex flex-wrap gap-3">
          <Button variant="outline" asChild>
            <Link
              href={`/admin/${params.cityId}/league/teams?division=${params.id}`}
            >
              <Users className="mr-2 h-4 w-4" />
              View Teams ({teamCount})
            </Link>
          </Button>
          <Button variant="outline" asChild>
            <Link href={`/admin/${params.cityId}/games?division=${params.id}`}>
              <Calendar className="mr-2 h-4 w-4" />
              View Schedule
            </Link>
          </Button>
        </CardContent>
      </Card>
    </div>
  );
}


----- app\admin\[cityId]\league\levels\new\page.tsx -----

// src/app/admin/[cityId]/league/levels/new/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Create level page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { CreateLevelForm } from "@/components/features/league/levels/CreateLevelForm";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";

interface CreateLevelPageProps {
  params: { cityId: string };
}

export default async function CreateLevelPage({
  params,
}: CreateLevelPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "manage_levels")) {
    redirect("/unauthorized");
  }

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center gap-4">
        <Button variant="ghost" size="sm" asChild>
          <Link href={`/admin/${params.cityId}/league/levels`}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back
          </Link>
        </Button>
      </div>

      <div>
        <h1 className="text-3xl font-bold tracking-tight">Add Skill Level</h1>
        <p className="text-gray-600 mt-1">
          Create a new skill level for division classification
        </p>
      </div>

      <div className="max-w-2xl">
        <CreateLevelForm cityId={params.cityId} />
      </div>
    </div>
  );
}


----- app\admin\[cityId]\league\levels\page.tsx -----

// src/app/admin/[cityId]/league/levels/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Levels list page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getAllLevels } from "@/lib/db/queries/levels";
import { LevelsTable } from "@/components/features/league/levels/LevelsTable";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Plus } from "lucide-react";

interface LevelsPageProps {
  params: { cityId: string };
}

export default async function LevelsPage({ params }: LevelsPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "manage_levels")) {
    redirect("/unauthorized");
  }

  const levels = await getAllLevels();

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">Skill Levels</h1>
          <p className="text-gray-600 mt-1">
            Manage skill levels for league divisions (Grade 1 = Highest)
          </p>
        </div>
        <Button asChild>
          <Link href={`/admin/${params.cityId}/league/levels/new`}>
            <Plus className="mr-2 h-4 w-4" />
            Add Level
          </Link>
        </Button>
      </div>

      <LevelsTable levels={levels} cityId={params.cityId} />
    </div>
  );
}


----- app\admin\[cityId]\league\locations\new\page.tsx -----

// src/app/admin/[cityId]/league/locations/new/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Create location page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getActiveCities } from "@/lib/db/queries/cities";
import { CreateLocationForm } from "@/components/features/league/locations/CreateLocationForm";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";

interface CreateLocationPageProps {
  params: { cityId: string };
}

export default async function CreateLocationPage({
  params,
}: CreateLocationPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "manage_locations")) {
    redirect("/unauthorized");
  }

  const cities = await getActiveCities();

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center gap-4">
        <Button variant="ghost" size="sm" asChild>
          <Link href={`/admin/${params.cityId}/league/locations`}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back
          </Link>
        </Button>
      </div>

      <div>
        <h1 className="text-3xl font-bold tracking-tight">Add Location</h1>
        <p className="text-gray-600 mt-1">
          Create a new venue location for league games
        </p>
      </div>

      <div className="max-w-2xl">
        <CreateLocationForm cities={cities} cityId={params.cityId} />
      </div>
    </div>
  );
}


----- app\admin\[cityId]\league\locations\page.tsx -----

// src/app/admin/[cityId]/league/locations/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Locations list page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getAllLocations } from "@/lib/db/queries/locations";
import { getActiveCities } from "@/lib/db/queries/cities";
import { LocationsTable } from "@/components/features/league/locations/LocationsTable";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Plus } from "lucide-react";

interface LocationsPageProps {
  params: { cityId: string };
}

export default async function LocationsPage({ params }: LocationsPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "manage_locations")) {
    redirect("/unauthorized");
  }

  const [locations, cities] = await Promise.all([
    getAllLocations(),
    getActiveCities(),
  ]);

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">Locations</h1>
          <p className="text-gray-600 mt-1">
            Manage venue locations for league operations
          </p>
        </div>
        <Button asChild>
          <Link href={`/admin/${params.cityId}/league/locations/new`}>
            <Plus className="mr-2 h-4 w-4" />
            Add Location
          </Link>
        </Button>
      </div>

      <LocationsTable
        locations={locations}
        cities={cities}
        cityId={params.cityId}
      />
    </div>
  );
}


----- app\admin\[cityId]\league\players\new\page.tsx -----

// src/app/admin/[cityId]/league/players/new/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Create player page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getActiveCities } from "@/lib/db/queries/cities";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { CreatePlayerForm } from "@/components/features/league/players/CreatePlayerForm";

interface CreatePlayerPageProps {
  params: { cityId: string };
}

export default async function CreatePlayerPage({
  params,
}: CreatePlayerPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "manage_players")) {
    redirect("/unauthorized");
  }

  const cities = await getActiveCities();

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center gap-4">
        <Button variant="ghost" size="sm" asChild>
          <Link href={`/admin/${params.cityId}/league/players`}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back
          </Link>
        </Button>
      </div>

      <div>
        <h1 className="text-3xl font-bold tracking-tight">Create Player</h1>
        <p className="text-gray-600 mt-1">
          Manually create a player profile. Payment and user account can be set
          up later.
        </p>
      </div>

      <div className="max-w-2xl">
        <CreatePlayerForm cityId={params.cityId} cities={cities} />
      </div>
    </div>
  );
}


----- app\admin\[cityId]\league\players\page.tsx -----

// src/app/admin/[cityId]/league/players/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Players list page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getPlayers } from "@/lib/db/queries/players";
import { getDivisions } from "@/lib/db/queries/divisions";
import { PlayersContent } from "@/components/features/league/players/PlayersContent";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Plus } from "lucide-react";

interface PlayersPageProps {
  params: { cityId: string };
  searchParams: {
    page?: string;
    payment?: string;
    division?: string;
    team?: string;
    freeAgents?: string;
    hasUser?: string;
    search?: string;
  };
}

export default async function PlayersPage({
  params,
  searchParams,
}: PlayersPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "view_players")) {
    redirect("/unauthorized");
  }

  const page = parseInt(searchParams.page || "1");
  const paymentFilter = (searchParams.payment || "all") as any;
  const freeAgentsOnly = searchParams.freeAgents === "true";
  const hasUserAccount = searchParams.hasUser
    ? searchParams.hasUser === "true"
    : undefined;

  const [result, divisions] = await Promise.all([
    getPlayers({
      cityId: params.cityId,
      page,
      paymentFilter,
      divisionId: searchParams.division,
      teamId: searchParams.team,
      freeAgentsOnly,
      hasUserAccount,
      search: searchParams.search,
    }),
    getDivisions({
      cityId: params.cityId,
      page: 1,
      limit: 100,
      activeFilter: "active",
    }),
  ]);

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">Players</h1>
          <p className="text-gray-600 mt-1">
            Manage player profiles and registrations
          </p>
        </div>
        {hasPermission(session, "manage_players") && (
          <Button asChild>
            <Link href={`/admin/${params.cityId}/league/players/new`}>
              <Plus className="mr-2 h-4 w-4" />
              Create Player
            </Link>
          </Button>
        )}
      </div>

      <PlayersContent
        players={result.players as any}
        pagination={result.pagination}
        divisions={divisions.divisions as any}
        cityId={params.cityId}
        currentFilters={{
          payment: paymentFilter,
          division: searchParams.division,
          team: searchParams.team,
          freeAgents: freeAgentsOnly,
          hasUser: hasUserAccount,
          search: searchParams.search,
        }}
      />
    </div>
  );
}


----- app\admin\[cityId]\league\players\[id]\edit\page.tsx -----

// src/app/admin/[cityId]/league/players/[id]/edit/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Edit player page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getPlayerById } from "@/lib/db/queries/players";
import { getActiveCities } from "@/lib/db/queries/cities";
import { EditPlayerForm } from "@/components/features/league/players/EditPlayerForm";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";

interface EditPlayerPageProps {
  params: { cityId: string; id: string };
}

export default async function EditPlayerPage({ params }: EditPlayerPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "manage_players")) {
    redirect("/unauthorized");
  }

  const [player, cities] = await Promise.all([
    getPlayerById(params.id),
    getActiveCities(),
  ]);

  if (!player) {
    redirect(`/admin/${params.cityId}/league/players`);
  }

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center gap-4">
        <Button variant="ghost" size="sm" asChild>
          <Link href={`/admin/${params.cityId}/league/players/${params.id}`}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back
          </Link>
        </Button>
      </div>

      <div>
        <h1 className="text-3xl font-bold tracking-tight">Edit Player</h1>
        <p className="text-gray-600 mt-1">
          Update player information and settings
        </p>
      </div>

      <div className="max-w-2xl">
        <EditPlayerForm
          player={player}
          cityId={params.cityId}
          cities={cities}
        />
      </div>
    </div>
  );
}


----- app\admin\[cityId]\league\players\[id]\page.tsx -----

// src/app/admin/[cityId]/league/players/[id]/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Player detail page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getPlayerById } from "@/lib/db/queries/players";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import Link from "next/link";
import {
  ArrowLeft,
  Pencil,
  Trophy,
  MapPin,
  Mail,
  Phone,
  Instagram,
  User,
  Building2,
  TrendingUp,
  DollarSign,
} from "lucide-react";
import { InstallmentProgress } from "@/components/features/payments/InstallmentProgress";
import { format } from "date-fns";

interface PlayerDetailPageProps {
  params: { cityId: string; id: string };
}

export default async function PlayerDetailPage({
  params,
}: PlayerDetailPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "view_players")) {
    redirect("/unauthorized");
  }

  const player = await getPlayerById(params.id);

  if (!player) {
    redirect(`/admin/${params.cityId}/league/players`);
  }

  return (
    <div className="p-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4">
          <Button variant="ghost" size="sm" asChild>
            <Link href={`/admin/${params.cityId}/league/players`}>
              <ArrowLeft className="h-4 w-4 mr-2" />
              Back
            </Link>
          </Button>
        </div>
        {hasPermission(session, "manage_players") && (
          <Button asChild>
            <Link
              href={`/admin/${params.cityId}/league/players/${params.id}/edit`}
            >
              <Pencil className="mr-2 h-4 w-4" />
              Edit Player
            </Link>
          </Button>
        )}
      </div>

      {/* Title & Status */}
      <div>
        <div className="flex items-center gap-3 mb-2">
          <h1 className="text-3xl font-bold tracking-tight">
            {player.playerName}
          </h1>
          {player.jerseyNumber && (
            <Badge variant="outline" className="text-lg px-3 py-1">
              #{player.jerseyNumber}
            </Badge>
          )}
        </div>
        <div className="flex items-center gap-2 mt-2">
          {player.paymentStatus === "paid" && (
            <Badge
              variant="outline"
              className="bg-green-100 text-green-800 border-green-200"
            >
              Paid
            </Badge>
          )}
          {player.paymentStatus === "in_progress" && (
            <Badge
              variant="outline"
              className="bg-blue-100 text-blue-800 border-blue-200"
            >
              Installments
            </Badge>
          )}
          {player.paymentStatus === "unpaid" && (
            <Badge
              variant="outline"
              className="bg-red-100 text-red-800 border-red-200"
            >
              Unpaid
            </Badge>
          )}
          {!player.team && (
            <Badge
              variant="outline"
              className="bg-yellow-100 text-yellow-800 border-yellow-200"
            >
              Free Agent
            </Badge>
          )}
        </div>
      </div>

      <div className="grid gap-6 md:grid-cols-2">
        {/* Player Details */}
        <Card>
          <CardHeader>
            <CardTitle>Player Details</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center gap-3">
              <Building2 className="h-5 w-5 text-gray-400" />
              <div>
                <p className="text-sm text-gray-500">City</p>
                <p className="font-medium">
                  {(player.division as any)?.city?.cityName || "N/A"}
                </p>
              </div>
            </div>

            <div className="flex items-center gap-3">
              <MapPin className="h-5 w-5 text-gray-400" />
              <div>
                <p className="text-sm text-gray-500">Location</p>
                <p className="font-medium">
                  {(player.division as any)?.location?.name || "N/A"}
                </p>
              </div>
            </div>

            <div className="flex items-center gap-3">
              <Trophy className="h-5 w-5 text-gray-400" />
              <div>
                <p className="text-sm text-gray-500">Division</p>
                <p className="font-medium">
                  {(player.division as any)?.divisionName || "N/A"}
                </p>
              </div>
            </div>

            <div className="flex items-center gap-3">
              <TrendingUp className="h-5 w-5 text-gray-400" />
              <div>
                <p className="text-sm text-gray-500">Skill Level</p>
                <p className="font-medium">
                  Grade {(player.division as any)?.level?.grade || "N/A"} -{" "}
                  {(player.division as any)?.level?.name || "N/A"}
                </p>
              </div>
            </div>

            <div className="flex items-center gap-3">
              <Trophy className="h-5 w-5 text-gray-400" />
              <div>
                <p className="text-sm text-gray-500">Team</p>
                <p className="font-medium">
                  {player.team ? (
                    <Link
                      href={`/admin/${params.cityId}/league/teams/${
                        (player.team as any)._id
                      }`}
                      className="text-blue-600 hover:underline"
                    >
                      {(player.team as any).teamName}
                    </Link>
                  ) : (
                    <span className="text-yellow-600">Free Agent</span>
                  )}
                </p>
              </div>
            </div>

            {player.instagram && (
              <div className="flex items-center gap-3">
                <Instagram className="h-5 w-5 text-gray-400" />
                <div>
                  <p className="text-sm text-gray-500">Instagram</p>
                  <p className="font-medium">{player.instagram}</p>
                </div>
              </div>
            )}
          </CardContent>
        </Card>

        {/* Payment Status */}
        <Card>
          <CardHeader>
            <CardTitle>Payment Status</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div>
              <p className="text-sm text-gray-500 mb-2">Status</p>
              {player.paymentStatus === "paid" && (
                <div className="flex items-center gap-2">
                  <Badge className="bg-green-100 text-green-800 border-green-200">
                    Fully Paid
                  </Badge>
                </div>
              )}
              {player.paymentStatus === "in_progress" && (
                <div className="space-y-3">
                  <Badge className="bg-blue-100 text-blue-800 border-blue-200">
                    Installment Plan Active
                  </Badge>
                  {player.installmentProgress && (
                    <div>
                      <p className="text-sm text-gray-500 mb-2">
                        Weekly Progress
                      </p>
                      <InstallmentProgress
                        payments={player.installmentProgress}
                        size="md"
                      />
                      <div className="mt-3 pt-3 border-t space-y-2">
                        <div className="flex justify-between text-sm">
                          <span className="text-gray-500">
                            Remaining Balance:
                          </span>
                          <span className="font-medium">
                            ${player.remainingBalance?.toFixed(2) || "0.00"}
                          </span>
                        </div>
                        {player.nextPaymentDate && (
                          <div className="flex justify-between text-sm">
                            <span className="text-gray-500">Next Payment:</span>
                            <span className="font-medium">
                              {format(
                                new Date(player.nextPaymentDate),
                                "MMM dd, yyyy"
                              )}
                            </span>
                          </div>
                        )}
                      </div>
                    </div>
                  )}
                </div>
              )}
              {player.paymentStatus === "unpaid" && (
                <Badge className="bg-red-100 text-red-800 border-red-200">
                  No Payment Recorded
                </Badge>
              )}
            </div>

            {hasPermission(session, "manage_payments") && (
              <Button variant="outline" className="w-full" asChild>
                <Link
                  href={`/admin/${params.cityId}/payments?player=${params.id}`}
                >
                  <DollarSign className="mr-2 h-4 w-4" />
                  Manage Payment
                </Link>
              </Button>
            )}
          </CardContent>
        </Card>
      </div>

      {/* User Account */}
      {player.user && (
        <Card>
          <CardHeader>
            <CardTitle>Linked User Account</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center gap-3">
              <User className="h-5 w-5 text-gray-400" />
              <div>
                <p className="text-sm text-gray-500">Name</p>
                <p className="font-medium">{(player.user as any).name}</p>
              </div>
            </div>

            <div className="flex items-center gap-3">
              <Mail className="h-5 w-5 text-gray-400" />
              <div>
                <p className="text-sm text-gray-500">Email</p>
                <p className="font-medium">{(player.user as any).email}</p>
              </div>
            </div>

            {(player.user as any).phoneNumber && (
              <div className="flex items-center gap-3">
                <Phone className="h-5 w-5 text-gray-400" />
                <div>
                  <p className="text-sm text-gray-500">Phone</p>
                  <p className="font-medium">
                    {(player.user as any).phoneNumber}
                  </p>
                </div>
              </div>
            )}

            {(player.user as any).instagram && (
              <div className="flex items-center gap-3">
                <Instagram className="h-5 w-5 text-gray-400" />
                <div>
                  <p className="text-sm text-gray-500">Instagram</p>
                  <p className="font-medium">
                    {(player.user as any).instagram}
                  </p>
                </div>
              </div>
            )}
          </CardContent>
        </Card>
      )}

      {!player.user && (
        <Card>
          <CardHeader>
            <CardTitle>User Account</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-center py-6">
              <User className="mx-auto h-12 w-12 text-gray-400" />
              <p className="mt-2 text-sm text-gray-500">
                No user account linked to this player
              </p>
              {hasPermission(session, "manage_players") && (
                <Button variant="outline" size="sm" className="mt-4" asChild>
                  <Link
                    href={`/admin/${params.cityId}/league/players/${params.id}/edit`}
                  >
                    Link User Account
                  </Link>
                </Button>
              )}
            </div>
          </CardContent>
        </Card>
      )}

      {/* Jersey Information */}
      <Card>
        <CardHeader>
          <CardTitle>Jersey Information</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid gap-4 md:grid-cols-3">
            <div>
              <p className="text-sm text-gray-500">Jersey Number</p>
              <p className="font-medium text-lg">
                {player.jerseyNumber
                  ? `#${player.jerseyNumber}`
                  : "Not assigned"}
              </p>
            </div>
            <div>
              <p className="text-sm text-gray-500">Jersey Size</p>
              <p className="font-medium">
                {player.jerseySize || "Not specified"}
              </p>
            </div>
            <div>
              <p className="text-sm text-gray-500">Jersey Name</p>
              <p className="font-medium">
                {player.jerseyName || "Not specified"}
              </p>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Game Statistics - Placeholder */}
      <Card>
        <CardHeader>
          <CardTitle>Game Statistics</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="text-center py-6">
            <Trophy className="mx-auto h-12 w-12 text-gray-400" />
            <p className="mt-2 text-sm text-gray-500">
              Game statistics will be tracked here
            </p>
            <p className="text-xs text-gray-400 mt-1">
              (Statistics tracking to be implemented)
            </p>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}


----- app\admin\[cityId]\league\prices\new\page.tsx -----

// src/app/admin/[cityId]/league/prices/new/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Create price page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { CreatePriceForm } from "@/components/features/league/prices/CreatePriceForm";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";

interface CreatePricePageProps {
  params: { cityId: string };
}

export default async function CreatePricePage({
  params,
}: CreatePricePageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "manage_prices")) {
    redirect("/unauthorized");
  }

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center gap-4">
        <Button variant="ghost" size="sm" asChild>
          <Link href={`/admin/${params.cityId}/league/prices`}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back
          </Link>
        </Button>
      </div>

      <div>
        <h1 className="text-3xl font-bold tracking-tight">Add Price</h1>
        <p className="text-gray-600 mt-1">
          Link an existing Stripe price to your system (Permanent - cannot be
          edited or deleted)
        </p>
      </div>

      <div className="max-w-2xl">
        <CreatePriceForm cityId={params.cityId} />
      </div>
    </div>
  );
}


----- app\admin\[cityId]\league\prices\page.tsx -----

// src/app/admin/[cityId]/league/prices/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Prices list page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getAllPrices } from "@/lib/db/queries/prices";
import { PricesGrid } from "@/components/features/league/prices/PricesGrid";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Plus } from "lucide-react";

interface PricesPageProps {
  params: { cityId: string };
}

export default async function PricesPage({ params }: PricesPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "manage_prices")) {
    redirect("/unauthorized");
  }

  const prices = await getAllPrices();

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">Prices</h1>
          <p className="text-gray-600 mt-1">
            Manage Stripe pricing for divisions (Prices are permanent once
            created)
          </p>
        </div>
        <Button asChild>
          <Link href={`/admin/${params.cityId}/league/prices/new`}>
            <Plus className="mr-2 h-4 w-4" />
            Add Price
          </Link>
        </Button>
      </div>

      <PricesGrid prices={prices} />
    </div>
  );
}


----- app\admin\[cityId]\league\teams\new\page.tsx -----

// src/app/admin/[cityId]/league/teams/new/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Create team page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getActiveCities } from "@/lib/db/queries/cities";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { CreateTeamForm } from "@/components/features/league/teams/CreateTeamForm";

interface CreateTeamPageProps {
  params: { cityId: string };
}

export default async function CreateTeamPage({ params }: CreateTeamPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "manage_teams")) {
    redirect("/unauthorized");
  }

  const cities = await getActiveCities();

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center gap-4">
        <Button variant="ghost" size="sm" asChild>
          <Link href={`/admin/${params.cityId}/league/teams`}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back
          </Link>
        </Button>
      </div>

      <div>
        <h1 className="text-3xl font-bold tracking-tight">Create Team</h1>
        <p className="text-gray-600 mt-1">
          Create a new team manually. Players and captain can be assigned after
          creation.
        </p>
      </div>

      <div className="max-w-2xl">
        <CreateTeamForm cityId={params.cityId} cities={cities} />
      </div>
    </div>
  );
}


----- app\admin\[cityId]\league\teams\page.tsx -----

// src/app/admin/[cityId]/league/teams/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Teams list page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getTeams } from "@/lib/db/queries/teams";
import { getDivisions } from "@/lib/db/queries/divisions";
import { getLocationsByCity } from "@/lib/db/queries/locations";
import { TeamsContent } from "@/components/features/league/teams/TeamsContent";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Plus } from "lucide-react";

interface TeamsPageProps {
  params: { cityId: string };
  searchParams: {
    page?: string;
    tab?: string;
    division?: string;
    location?: string;
    search?: string;
    view?: string;
  };
}

export default async function TeamsPage({
  params,
  searchParams,
}: TeamsPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "view_teams")) {
    redirect("/unauthorized");
  }

  const page = parseInt(searchParams.page || "1");
  const tab = (searchParams.tab || "all") as any;
  const viewMode = (searchParams.view || "card") as any;

  const [result, divisions, locations] = await Promise.all([
    getTeams({
      cityId: params.cityId,
      page,
      paymentFilter: tab,
      divisionId: searchParams.division,
      locationId: searchParams.location,
      search: searchParams.search,
      viewMode,
    }),
    getDivisions({
      cityId: params.cityId,
      page: 1,
      limit: 100,
      activeFilter: "all",
    }),
    getLocationsByCity(params.cityId),
  ]);

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">Teams</h1>
          <p className="text-gray-600 mt-1">
            Manage teams, rosters, and assignments
          </p>
        </div>
        <Button asChild>
          <Link href={`/admin/${params.cityId}/league/teams/new`}>
            <Plus className="mr-2 h-4 w-4" />
            Create Team
          </Link>
        </Button>
      </div>

      <TeamsContent
        teams={result.teams as any}
        pagination={result.pagination}
        divisions={divisions.divisions as any}
        locations={locations as any}
        cityId={params.cityId}
        currentTab={tab}
        currentView={viewMode}
        currentFilters={{
          division: searchParams.division,
          location: searchParams.location,
          search: searchParams.search,
        }}
      />
    </div>
  );
}


----- app\admin\[cityId]\league\teams\[id]\edit\page.tsx -----

// src/app/admin/[cityId]/league/teams/[id]/edit/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Edit team page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getTeamById } from "@/lib/db/queries/teams";
import { getActiveCities } from "@/lib/db/queries/cities";
import { EditTeamForm } from "@/components/features/league/teams/EditTeamForm";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";

interface EditTeamPageProps {
  params: { cityId: string; id: string };
}

export default async function EditTeamPage({ params }: EditTeamPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "manage_teams")) {
    redirect("/unauthorized");
  }

  const [team, cities] = await Promise.all([
    getTeamById(params.id),
    getActiveCities(),
  ]);

  if (!team) {
    redirect(`/admin/${params.cityId}/league/teams`);
  }

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center gap-4">
        <Button variant="ghost" size="sm" asChild>
          <Link href={`/admin/${params.cityId}/league/teams/${params.id}`}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back
          </Link>
        </Button>
      </div>

      <div>
        <h1 className="text-3xl font-bold tracking-tight">Edit Team</h1>
        <p className="text-gray-600 mt-1">
          Update team information and settings
        </p>
      </div>

      <div className="max-w-2xl">
        <EditTeamForm team={team} cityId={params.cityId} cities={cities} />
      </div>
    </div>
  );
}


----- app\admin\[cityId]\league\teams\[id]\page.tsx -----

// src/app/admin/[cityId]/league/teams/[id]/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Team detail page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getTeamById, getTeamStats } from "@/lib/db/queries/teams";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import Link from "next/link";
import {
  ArrowLeft,
  Pencil,
  MapPin,
  Trophy,
  Users,
  Calendar,
  AlertCircle,
  Building2,
  TrendingUp,
} from "lucide-react";

interface TeamDetailPageProps {
  params: { cityId: string; id: string };
}

export default async function TeamDetailPage({ params }: TeamDetailPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "view_teams")) {
    redirect("/unauthorized");
  }

  const [team, stats] = await Promise.all([
    getTeamById(params.id),
    getTeamStats(params.id),
  ]);

  if (!team) {
    redirect(`/admin/${params.cityId}/league/teams`);
  }

  const noCaptainWarning =
    !team.teamCaptain && team.players && team.players.length > 0;

  return (
    <div className="p-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4">
          <Button variant="ghost" size="sm" asChild>
            <Link href={`/admin/${params.cityId}/league/teams`}>
              <ArrowLeft className="h-4 w-4 mr-2" />
              Back
            </Link>
          </Button>
        </div>
        {hasPermission(session, "manage_teams") && (
          <Button asChild>
            <Link
              href={`/admin/${params.cityId}/league/teams/${params.id}/edit`}
            >
              <Pencil className="mr-2 h-4 w-4" />
              Edit Team
            </Link>
          </Button>
        )}
      </div>

      {/* Title & Basic Info */}
      <div>
        <div className="flex items-center gap-3 mb-2">
          <h1 className="text-3xl font-bold tracking-tight">{team.teamName}</h1>
          {noCaptainWarning && (
            <Badge
              variant="outline"
              className="bg-yellow-100 text-yellow-800 border-yellow-200"
            >
              <AlertCircle className="h-4 w-4 mr-1" />
              No Captain
            </Badge>
          )}
        </div>
        <p className="text-gray-600">{team.teamNameShort}</p>
        <p className="text-sm text-gray-500 font-mono mt-1">{team.teamCode}</p>
      </div>

      <div className="grid gap-6 md:grid-cols-2">
        {/* Team Details */}
        <Card>
          <CardHeader>
            <CardTitle>Team Details</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center gap-3">
              <Building2 className="h-5 w-5 text-gray-400" />
              <div>
                <p className="text-sm text-gray-500">City</p>
                <p className="font-medium">
                  {(team.division as any)?.city?.cityName || "N/A"}
                </p>
              </div>
            </div>

            <div className="flex items-center gap-3">
              <MapPin className="h-5 w-5 text-gray-400" />
              <div>
                <p className="text-sm text-gray-500">Location</p>
                <p className="font-medium">
                  {(team.division as any)?.location?.name || "N/A"}
                </p>
              </div>
            </div>

            <div className="flex items-center gap-3">
              <Trophy className="h-5 w-5 text-gray-400" />
              <div>
                <p className="text-sm text-gray-500">Division</p>
                <p className="font-medium">
                  {(team.division as any)?.divisionName || "N/A"}
                </p>
              </div>
            </div>

            <div className="flex items-center gap-3">
              <TrendingUp className="h-5 w-5 text-gray-400" />
              <div>
                <p className="text-sm text-gray-500">Skill Level</p>
                <p className="font-medium">
                  Grade {(team.division as any)?.level?.grade || "N/A"} -{" "}
                  {(team.division as any)?.level?.name || "N/A"}
                </p>
              </div>
            </div>

            <div className="flex items-center gap-3">
              <Users className="h-5 w-5 text-gray-400" />
              <div>
                <p className="text-sm text-gray-500">Team Captain</p>
                <p className="font-medium">
                  {(team.teamCaptain as any)?.playerName || (
                    <span className="text-yellow-600">Not assigned</span>
                  )}
                </p>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Statistics */}
        <Card>
          <CardHeader>
            <CardTitle>Statistics</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div>
              <p className="text-sm text-gray-500 mb-2">Record</p>
              <p className="text-3xl font-bold">
                {stats?.wins || 0}-{stats?.losses || 0}
              </p>
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div>
                <p className="text-sm text-gray-500">Wins</p>
                <p className="text-2xl font-bold text-green-600">
                  {stats?.wins || 0}
                </p>
              </div>
              <div>
                <p className="text-sm text-gray-500">Losses</p>
                <p className="text-2xl font-bold text-red-600">
                  {stats?.losses || 0}
                </p>
              </div>
            </div>

            <div>
              <p className="text-sm text-gray-500">Point Differential</p>
              <p className="text-2xl font-bold">
                {stats?.pointDifference && stats.pointDifference > 0 ? "+" : ""}
                {stats?.pointDifference || 0}
              </p>
            </div>

            <div>
              <p className="text-sm text-gray-500">Total Players</p>
              <p className="text-2xl font-bold">{team.players?.length || 0}</p>
            </div>

            <div>
              <p className="text-sm text-gray-500">Games Played</p>
              <p className="text-2xl font-bold">{team.games?.length || 0}</p>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Roster */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle>Roster ({team.players?.length || 0} Players)</CardTitle>
            {hasPermission(session, "manage_teams") && (
              <Button size="sm" asChild>
                <Link
                  href={`/admin/${params.cityId}/league/teams/${params.id}/roster`}
                >
                  Manage Roster
                </Link>
              </Button>
            )}
          </div>
        </CardHeader>
        <CardContent>
          {!team.players || team.players.length === 0 ? (
            <div className="text-center py-8">
              <Users className="mx-auto h-12 w-12 text-gray-400" />
              <p className="mt-2 text-sm text-gray-500">
                No players on this team yet
              </p>
              {hasPermission(session, "manage_teams") && (
                <Button variant="outline" size="sm" className="mt-4" asChild>
                  <Link
                    href={`/admin/${params.cityId}/league/teams/${params.id}/roster`}
                  >
                    Add Players
                  </Link>
                </Button>
              )}
            </div>
          ) : (
            <div className="space-y-2">
              {team.players.map((player: any) => (
                <div
                  key={player._id}
                  className="flex items-center justify-between p-3 rounded-lg hover:bg-gray-50"
                >
                  <div className="flex items-center gap-3">
                    <div className="flex items-center justify-center w-10 h-10 rounded-full bg-gray-100 font-bold text-gray-600">
                      {player.jerseyNumber || "—"}
                    </div>
                    <div>
                      <p className="font-medium">{player.playerName}</p>
                      {player._id === team.teamCaptain?._id && (
                        <Badge variant="outline" className="mt-1">
                          Captain
                        </Badge>
                      )}
                    </div>
                  </div>
                  <Button variant="ghost" size="sm" asChild>
                    <Link
                      href={`/admin/${params.cityId}/league/players/${player._id}`}
                    >
                      View
                    </Link>
                  </Button>
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>

      {/* Game History */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle>
              Game History ({team.games?.length || 0} Games)
            </CardTitle>
            <Button variant="outline" size="sm" asChild>
              <Link href={`/admin/${params.cityId}/games?team=${params.id}`}>
                View All Games
              </Link>
            </Button>
          </div>
        </CardHeader>
        <CardContent>
          {!team.games || team.games.length === 0 ? (
            <div className="text-center py-8">
              <Calendar className="mx-auto h-12 w-12 text-gray-400" />
              <p className="mt-2 text-sm text-gray-500">No games played yet</p>
            </div>
          ) : (
            <div className="text-sm text-gray-600">
              <p>Game history will be displayed here</p>
              <p className="text-xs text-gray-500 mt-1">
                (Full game history component to be implemented)
              </p>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Jersey Information */}
      {(team.primaryColor ||
        team.secondaryColor ||
        team.jerseyEdition ||
        team.isCustomJersey) && (
        <Card>
          <CardHeader>
            <CardTitle>Jersey Information</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            {team.isCustomJersey ? (
              <div>
                <p className="text-sm text-gray-500">Jersey Type</p>
                <p className="font-medium">Custom Jersey</p>
              </div>
            ) : team.jerseyEdition ? (
              <div>
                <p className="text-sm text-gray-500">Jersey Edition</p>
                <p className="font-medium">{team.jerseyEdition}</p>
              </div>
            ) : null}

            {(team.primaryColor ||
              team.secondaryColor ||
              team.tertiaryColor) && (
              <div>
                <p className="text-sm text-gray-500 mb-2">Team Colors</p>
                <div className="flex gap-3">
                  {team.primaryColor && (
                    <div className="flex items-center gap-2">
                      <div
                        className="w-10 h-10 rounded border"
                        style={{ backgroundColor: team.primaryColor }}
                      />
                      <span className="text-xs text-gray-500">Primary</span>
                    </div>
                  )}
                  {team.secondaryColor && (
                    <div className="flex items-center gap-2">
                      <div
                        className="w-10 h-10 rounded border"
                        style={{ backgroundColor: team.secondaryColor }}
                      />
                      <span className="text-xs text-gray-500">Secondary</span>
                    </div>
                  )}
                  {team.tertiaryColor && (
                    <div className="flex items-center gap-2">
                      <div
                        className="w-10 h-10 rounded border"
                        style={{ backgroundColor: team.tertiaryColor }}
                      />
                      <span className="text-xs text-gray-500">Tertiary</span>
                    </div>
                  )}
                </div>
              </div>
            )}
          </CardContent>
        </Card>
      )}
    </div>
  );
}


----- app\admin\[cityId]\league\teams\[id]\roster\page.tsx -----

// src/app/admin/[cityId]/league/teams/[id]/roster/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Roster management page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getTeamById } from "@/lib/db/queries/teams";
import { RosterManager } from "@/components/features/league/teams/RosterManager";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";

interface RosterPageProps {
  params: { cityId: string; id: string };
}

export default async function RosterPage({ params }: RosterPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "manage_teams")) {
    redirect("/unauthorized");
  }

  const team = await getTeamById(params.id);

  if (!team) {
    redirect(`/admin/${params.cityId}/league/teams`);
  }

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center gap-4">
        <Button variant="ghost" size="sm" asChild>
          <Link href={`/admin/${params.cityId}/league/teams/${params.id}`}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back to Team
          </Link>
        </Button>
      </div>

      <div>
        <h1 className="text-3xl font-bold tracking-tight">
          Manage Roster - {team.teamName}
        </h1>
        <p className="text-gray-600 mt-1">
          Add or remove players from the team roster
        </p>
      </div>

      <RosterManager team={team} cityId={params.cityId} />
    </div>
  );
}


----- app\admin\[cityId]\payments\page.tsx -----

// src/app/admin/[cityId]/payments/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Payment dashboard page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getPlayersWithPaymentStatus } from "@/lib/db/queries/payments";
import { getLocationsByCity } from "@/lib/db/queries/locations";
import { getDivisions } from "@/lib/db/queries/divisions";
import { PaymentDashboard } from "@/components/features/payments/PaymentDashboard";

interface PaymentPageProps {
  params: { cityId: string };
  searchParams: {
    location?: string;
    division?: string;
    team?: string;
    payment?: string;
    search?: string;
  };
}

export default async function PaymentPage({
  params,
  searchParams,
}: PaymentPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "view_payments")) {
    redirect("/unauthorized");
  }

  const [players, locations, divisions] = await Promise.all([
    getPlayersWithPaymentStatus({
      cityId: params.cityId,
      locationId: searchParams.location,
      divisionId: searchParams.division,
      teamId: searchParams.team,
      paymentStatusFilter: searchParams.payment || "all",
      search: searchParams.search,
    }),
    getLocationsByCity(params.cityId),
    getDivisions({
      cityId: params.cityId,
      page: 1,
      limit: 100,
      activeFilter: "active",
    }),
  ]);

  return (
    <div className="p-6 space-y-6">
      <div>
        <h1 className="text-3xl font-bold tracking-tight">Payment Management</h1>
        <p className="text-gray-600 mt-1">
          Track player payments and manage installment plans
        </p>
      </div>

      <PaymentDashboard
        players={JSON.parse(JSON.stringify(players))}
        locations={JSON.parse(JSON.stringify(locations))}
        divisions={JSON.parse(JSON.stringify(divisions.divisions))}
        cityId={params.cityId}
        currentFilters={{
          location: searchParams.location,
          division: searchParams.division,
          team: searchParams.team,
          payment: searchParams.payment || "all",
          search: searchParams.search,
        }}
      />
    </div>
  );
}

----- app\admin\[cityId]\payments\[playerId]\page.tsx -----

// src/app/admin/[cityId]/payments/[playerId]/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Player payment detail page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getPlayerById } from "@/lib/db/queries/players";
import { getPlayerPaymentStatus } from "@/lib/db/queries/payments";
import { UnpaidPlayerView } from "@/components/features/payments/UnpaidPlayerView";
import { PaidPlayerView } from "@/components/features/payments/PaidPlayerView";
import { OnTrackPlayerView } from "@/components/features/payments/OnTrackPlayerView";
import { HasIssuesPlayerView } from "@/components/features/payments/HasIssuesPlayerView";
import { CriticalPlayerView } from "@/components/features/payments/CriticalPlayerView";

interface PlayerPaymentPageProps {
  params: { cityId: string; playerId: string };
}

export default async function PlayerPaymentPage({ params }: PlayerPaymentPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "view_payments")) {
    redirect("/unauthorized");
  }

  const player = await getPlayerById(params.playerId);

  if (!player) {
    redirect(`/admin/${params.cityId}/payments`);
  }

  const { status, paymentMethod } = await getPlayerPaymentStatus(params.playerId);

  // Route to appropriate view based on payment status
  const renderView = () => {
    switch (status) {
      case "unpaid":
        return <UnpaidPlayerView player={player} cityId={params.cityId} />;
      case "paid":
        return <PaidPlayerView player={player} paymentMethod={paymentMethod} cityId={params.cityId} />;
      case "on-track":
        return <OnTrackPlayerView player={player} paymentMethod={paymentMethod} cityId={params.cityId} />;
      case "has-issues":
        return <HasIssuesPlayerView player={player} paymentMethod={paymentMethod} cityId={params.cityId} />;
      case "critical":
        return <CriticalPlayerView player={player} paymentMethod={paymentMethod} cityId={params.cityId} />;
      default:
        return <UnpaidPlayerView player={player} cityId={params.cityId} />;
    }
  };

  return renderView();
}

----- app\admin\[cityId]\settings\admins\new\page.tsx -----

// src/app/admin/[cityId]/settings/admins/new/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Create admin page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getLocationsByCity } from "@/lib/db/queries/locations";
import { CreateAdminForm } from "@/components/features/admins/CreateAdminForm";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";

interface CreateAdminPageProps {
  params: { cityId: string };
}

export default async function CreateAdminPage({
  params,
}: CreateAdminPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  if (!hasPermission(session, "manage_admins")) {
    redirect("/unauthorized");
  }

  const locations = await getLocationsByCity(params.cityId);

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center gap-4">
        <Button variant="ghost" size="sm" asChild>
          <Link href={`/admin/${params.cityId}/settings/admins`}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back
          </Link>
        </Button>
      </div>

      <div>
        <h1 className="text-3xl font-bold tracking-tight">Add Staff Member</h1>
        <p className="text-gray-600 mt-1">
          Create a new admin account with role and location access
        </p>
      </div>

      <div className="max-w-2xl">
        <CreateAdminForm locations={locations} cityId={params.cityId} />
      </div>
    </div>
  );
}


----- app\admin\[cityId]\settings\admins\page.tsx -----

// src/app/admin/[cityId]/settings/admins/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Admin list page orchestration ONLY
 */

import { getServerSession } from "next-auth";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth/auth.config";
import { getAdmins } from "@/lib/db/queries/admins";
import { hasPermission } from "@/lib/auth/permissions";
import { AdminsTable } from "@/components/features/admins/AdminsTable";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Plus } from "lucide-react";

interface AdminsPageProps {
  params: { cityId: string };
}

export default async function AdminsPage({ params }: AdminsPageProps) {
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  // Check permission
  if (!hasPermission(session, "manage_admins")) {
    redirect("/unauthorized");
  }

  const admins = await getAdmins();

  return (
    <div className="p-6 space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">
            Staff Management
          </h1>
          <p className="text-gray-600 mt-1">
            Manage admin accounts and permissions
          </p>
        </div>
        <Button asChild>
          <Link href={`/admin/${params.cityId}/settings/admins/new`}>
            <Plus className="mr-2 h-4 w-4" />
            Add Staff
          </Link>
        </Button>
      </div>

      <AdminsTable admins={admins} cityId={params.cityId} />
    </div>
  );
}


----- app\api\auth\[...nextauth]\route.ts -----

// src/app/api/auth/[...nextauth]/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * NextAuth handler ONLY
 */

import NextAuth from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };


----- app\api\v1\admins\route.ts -----

// src/app/api/v1/admins/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Admins API endpoint ONLY
 */

/**
 * Security
 * Only EXECUTIVE can manage admins
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { getAdmins, createAdmin, emailExists } from "@/lib/db/queries/admins";
import { z } from "zod";

// Validation schema
const createAdminSchema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
  password: z
    .string()
    .min(8)
    .regex(/[A-Z]/, "Must contain uppercase letter")
    .regex(/[a-z]/, "Must contain lowercase letter")
    .regex(/[0-9]/, "Must contain number"),
  phoneNumber: z.string().optional(),
  role: z.enum(["EXECUTIVE", "COMMISSIONER", "SCOREKEEPER", "PHOTOGRAPHER"]),
  assignedLocations: z.array(z.string()).optional(),
});

/**
 * GET /api/v1/admins
 * Fetch all admins (EXECUTIVE only)
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || session.user.role !== "EXECUTIVE") {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const admins = await getAdmins();

    return NextResponse.json({ success: true, data: admins }, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching admins:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch admins" },
      { status: 500 }
    );
  }
}

/**
 * POST /api/v1/admins
 * Create new admin (EXECUTIVE only)
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || session.user.role !== "EXECUTIVE") {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    // Parse and validate body
    const body = await request.json();
    const validatedData = createAdminSchema.parse(body);

    // Check if email exists
    const exists = await emailExists(validatedData.email);
    if (exists) {
      return NextResponse.json(
        { success: false, error: "Email already exists" },
        { status: 409 }
      );
    }

    // Create admin
    const admin = await createAdmin(validatedData);

    return NextResponse.json({ success: true, data: admin }, { status: 201 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error creating admin:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to create admin" },
      { status: 500 }
    );
  }
}


----- app\api\v1\cities\route.ts -----

// src/app/api/v1/cities/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Cities API endpoint ONLY
 */

/**
 * Error Handling & Resilience
 * Proper error responses with status codes
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { getActiveCities } from "@/lib/db/queries/cities";

/**
 * GET /api/v1/cities
 * Fetch all active cities
 */
export async function GET(request: NextRequest) {
  try {
    // Auth check
    const session = await getServerSession(authOptions);

    if (!session) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Fetch cities
    const cities = await getActiveCities();

    return NextResponse.json({ success: true, data: cities }, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching cities:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch cities" },
      { status: 500 }
    );
  }
}


----- app\api\v1\league\cities\route.ts -----

// src/app/api/v1/league/cities/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Cities API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import {
  getAllCities,
  createCity,
  updateCity,
  deleteCity,
  cityNameExists,
} from "@/lib/db/queries/cities";
import { z } from "zod";

import { createCitySchema, updateCitySchema } from "@/lib/validations/city";

/**
 * GET /api/v1/league/cities
 * Get all cities (EXECUTIVE only)
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_cities")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const cities = await getAllCities();

    return NextResponse.json({ success: true, data: cities }, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching cities:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch cities" },
      { status: 500 }
    );
  }
}

/**
 * POST /api/v1/league/cities
 * Create city (EXECUTIVE only)
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    console.log("Session:", session); // Add this
    console.log("Has permission:", hasPermission(session, "manage_cities")); // Add this

    if (!session || !hasPermission(session, "manage_cities")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = createCitySchema.parse(body);

    // Check if city exists
    const exists = await cityNameExists(
      validatedData.cityName,
      validatedData.region,
      validatedData.country
    );

    if (exists) {
      return NextResponse.json(
        { success: false, error: "City already exists in this region" },
        { status: 409 }
      );
    }

    const city = await createCity(validatedData);

    return NextResponse.json({ success: true, data: city }, { status: 201 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error creating city:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to create city" },
      { status: 500 }
    );
  }
}

/**
 * PATCH /api/v1/league/cities
 * Update city (EXECUTIVE only)
 */
export async function PATCH(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_cities")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = updateCitySchema.parse(body);

    const { id, ...updateData } = validatedData;

    const city = await updateCity(id, updateData);

    if (!city) {
      return NextResponse.json(
        { success: false, error: "City not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, data: city }, { status: 200 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error updating city:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to update city" },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/v1/league/cities
 * Delete city (EXECUTIVE only)
 */
export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_cities")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const id = searchParams.get("id");

    if (!id) {
      return NextResponse.json(
        { success: false, error: "City ID is required" },
        { status: 400 }
      );
    }

    await deleteCity(id);

    return NextResponse.json(
      { success: true, message: "City deleted successfully" },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error deleting city:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to delete city" },
      { status: 500 }
    );
  }
}


----- app\api\v1\league\levels\route.ts -----

// src/app/api/v1/league/levels/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Levels API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import {
  getAllLevels,
  createLevel,
  updateLevel,
  levelNameExists,
  gradeExists,
} from "@/lib/db/queries/levels";
import { createLevelSchema, updateLevelSchema } from "@/lib/validations/level";
import { z } from "zod";

/**
 * GET /api/v1/league/levels
 * Get all levels (EXECUTIVE only)
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_levels")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const levels = await getAllLevels();

    return NextResponse.json({ success: true, data: levels }, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching levels:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch levels" },
      { status: 500 }
    );
  }
}

/**
 * POST /api/v1/league/levels
 * Create level (EXECUTIVE only)
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_levels")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = createLevelSchema.parse(body);

    // Check if level name exists
    const nameExists = await levelNameExists(validatedData.name);
    if (nameExists) {
      return NextResponse.json(
        { success: false, error: "Level name already exists" },
        { status: 409 }
      );
    }

    // Check if grade exists
    const gradeAlreadyExists = await gradeExists(validatedData.grade);
    if (gradeAlreadyExists) {
      return NextResponse.json(
        { success: false, error: "Grade number already exists" },
        { status: 409 }
      );
    }

    const level = await createLevel(validatedData);

    return NextResponse.json({ success: true, data: level }, { status: 201 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error creating level:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to create level" },
      { status: 500 }
    );
  }
}

/**
 * PATCH /api/v1/league/levels
 * Update level (EXECUTIVE only)
 */
export async function PATCH(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_levels")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = updateLevelSchema.parse(body);

    const { id, ...updateData } = validatedData;

    // Check if name exists (excluding current level)
    if (updateData.name) {
      const nameExists = await levelNameExists(updateData.name, id);
      if (nameExists) {
        return NextResponse.json(
          { success: false, error: "Level name already exists" },
          { status: 409 }
        );
      }
    }

    // Check if grade exists (excluding current level)
    if (updateData.grade) {
      const gradeAlreadyExists = await gradeExists(updateData.grade, id);
      if (gradeAlreadyExists) {
        return NextResponse.json(
          { success: false, error: "Grade number already exists" },
          { status: 409 }
        );
      }
    }

    const level = await updateLevel(id, updateData);

    if (!level) {
      return NextResponse.json(
        { success: false, error: "Level not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, data: level }, { status: 200 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error updating level:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to update level" },
      { status: 500 }
    );
  }
}


----- app\api\v1\league\locations\route.ts -----

// src/app/api/v1/league/locations/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Locations API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import {
  getAllLocations,
  createLocation,
  updateLocation,
  deleteLocation,
  locationHasActiveDivisions,
} from "@/lib/db/queries/locations";
import {
  createLocationSchema,
  updateLocationSchema,
} from "@/lib/validations/location";
import { z } from "zod";

/**
 * GET /api/v1/league/locations
 * Get all locations (EXECUTIVE only)
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_locations")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const cityId = searchParams.get("cityId");

    let locations;
    if (cityId) {
      const { getLocationsByCity } = await import("@/lib/db/queries/locations");
      locations = await getLocationsByCity(cityId);
    } else {
      locations = await getAllLocations();
    }

    return NextResponse.json(
      { success: true, data: locations },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error fetching locations:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch locations" },
      { status: 500 }
    );
  }
}

/**
 * POST /api/v1/league/locations
 * Create location (EXECUTIVE only)
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_locations")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = createLocationSchema.parse(body);

    const location = await createLocation(validatedData);

    return NextResponse.json(
      { success: true, data: location },
      { status: 201 }
    );
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error creating location:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to create location" },
      { status: 500 }
    );
  }
}

/**
 * PATCH /api/v1/league/locations
 * Update location (EXECUTIVE only)
 */
export async function PATCH(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_locations")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = updateLocationSchema.parse(body);

    const { id, ...updateData } = validatedData;

    const location = await updateLocation(id, updateData);

    if (!location) {
      return NextResponse.json(
        { success: false, error: "Location not found" },
        { status: 404 }
      );
    }

    return NextResponse.json(
      { success: true, data: location },
      { status: 200 }
    );
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error updating location:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to update location" },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/v1/league/locations
 * Delete location (EXECUTIVE only)
 */
export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_locations")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const id = searchParams.get("id");

    if (!id) {
      return NextResponse.json(
        { success: false, error: "Location ID is required" },
        { status: 400 }
      );
    }

    // Check if location has active divisions
    const hasActiveDivisions = await locationHasActiveDivisions(id);
    if (hasActiveDivisions) {
      return NextResponse.json(
        {
          success: false,
          error: "Cannot delete location with active divisions",
        },
        { status: 400 }
      );
    }

    await deleteLocation(id);

    return NextResponse.json(
      { success: true, message: "Location deleted successfully" },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error deleting location:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to delete location" },
      { status: 500 }
    );
  }
}


----- app\api\v1\league\prices\route.ts -----

// src/app/api/v1/league/prices/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Prices API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import {
  getAllPrices,
  createPrice,
  stripePriceIdExists,
} from "@/lib/db/queries/prices";
import { createPriceSchema } from "@/lib/validations/price";
import { z } from "zod";

/**
 * GET /api/v1/league/prices
 * Get all prices (EXECUTIVE only)
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_prices")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const prices = await getAllPrices();

    return NextResponse.json({ success: true, data: prices }, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching prices:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch prices" },
      { status: 500 }
    );
  }
}

/**
 * POST /api/v1/league/prices
 * Create price (EXECUTIVE only)
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_prices")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = createPriceSchema.parse(body);

    // Check if Stripe price ID already exists
    const exists = await stripePriceIdExists(validatedData.priceId);
    if (exists) {
      return NextResponse.json(
        { success: false, error: "This Stripe price ID is already registered" },
        { status: 409 }
      );
    }

    const price = await createPrice(validatedData);

    return NextResponse.json({ success: true, data: price }, { status: 201 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error creating price:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to create price" },
      { status: 500 }
    );
  }
}


----- app\api\v1\[cityId]\divisions\route.ts -----

// src/app/api/v1/[cityId]/divisions/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Divisions API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import {
  getDivisions,
  createDivision,
  checkLocationConflict,
  getDivisionById,
  updateDivision,
} from "@/lib/db/queries/divisions";
import {
  createDivisionSchema,
  updateDivisionSchema,
} from "@/lib/validations/division"; // ADD updateDivisionSchema
import { z } from "zod";

/**
 * GET /api/v1/[cityId]/divisions
 * Get divisions with pagination (EXECUTIVE + COMMISSIONER)
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "view_divisions")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1");
    const activeFilter = (searchParams.get("tab") as any) || "all";
    const locationId = searchParams.get("location") || undefined;
    const levelId = searchParams.get("level") || undefined;
    const day = searchParams.get("day") || undefined;
    const search = searchParams.get("search") || undefined;

    const result = await getDivisions({
      cityId: params.cityId,
      page,
      activeFilter,
      locationId,
      levelId,
      day,
      search,
    });

    return NextResponse.json({ success: true, data: result }, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching divisions:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch divisions" },
      { status: 500 }
    );
  }
}

/**
 * POST /api/v1/[cityId]/divisions
 * Create division (EXECUTIVE + COMMISSIONER)
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_divisions")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = createDivisionSchema.parse(body);

    // Check for location conflicts (warning only)
    let conflictWarning = null;
    if (validatedData.startTime && validatedData.endTime) {
      const conflict = await checkLocationConflict(
        validatedData.location,
        validatedData.day,
        validatedData.startTime,
        validatedData.endTime
      );

      if (conflict.hasConflict) {
        conflictWarning = {
          message: `${conflict.conflictingDivision.divisionName} uses this location on ${validatedData.day}s from ${conflict.conflictingDivision.startTime} - ${conflict.conflictingDivision.endTime}`,
        };
      }
    }

    const division = await createDivision({
      ...validatedData,
      city: params.cityId,
    });

    return NextResponse.json(
      {
        success: true,
        data: division,
        warning: conflictWarning,
      },
      { status: 201 }
    );
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error creating division:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to create division" },
      { status: 500 }
    );
  }
}

// src/app/api/v1/[cityId]/divisions/route.ts - Add PATCH method

/**
 * PATCH /api/v1/[cityId]/divisions
 * Update division (EXECUTIVE + COMMISSIONER)
 */
// src/app/api/v1/[cityId]/divisions/route.ts - Update PATCH method

export async function PATCH(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_divisions")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = updateDivisionSchema.parse(body);

    const { id, ...updateData } = validatedData;

    // Check for location conflicts if location/time is being updated
    let conflictWarning = null;
    if (
      updateData.location ||
      updateData.day ||
      updateData.startTime ||
      updateData.endTime
    ) {
      const currentDivision = await getDivisionById(id);

      // Add null check
      if (!currentDivision) {
        return NextResponse.json(
          { success: false, error: "Division not found" },
          { status: 404 }
        );
      }

      // Convert ObjectId to string with proper type handling
      const locationToCheck =
        updateData.location ||
        (typeof currentDivision.location === "object" &&
        currentDivision.location._id
          ? currentDivision.location._id.toString()
          : currentDivision.location?.toString() || "");

      const dayToCheck = updateData.day || currentDivision.day;
      const startTimeToCheck =
        updateData.startTime || currentDivision.startTime;
      const endTimeToCheck = updateData.endTime || currentDivision.endTime;

      if (startTimeToCheck && endTimeToCheck) {
        const conflict = await checkLocationConflict(
          locationToCheck,
          dayToCheck,
          startTimeToCheck,
          endTimeToCheck,
          id
        );

        if (conflict.hasConflict) {
          conflictWarning = {
            message: `${conflict.conflictingDivision.divisionName} uses this location on ${dayToCheck}s from ${conflict.conflictingDivision.startTime} - ${conflict.conflictingDivision.endTime}`,
          };
        }
      }
    }

    const division = await updateDivision(id, updateData);

    if (!division) {
      return NextResponse.json(
        { success: false, error: "Division not found" },
        { status: 404 }
      );
    }

    return NextResponse.json(
      {
        success: true,
        data: division,
        warning: conflictWarning,
      },
      { status: 200 }
    );
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error updating division:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to update division" },
      { status: 500 }
    );
  }
}


----- app\api\v1\[cityId]\locations\route.ts -----

// src/app/api/v1/[cityId]/locations/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Locations API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { getLocationsByCity } from "@/lib/db/queries/locations";

/**
 * GET /api/v1/[cityId]/locations
 * Fetch locations for a specific city
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    // Auth check
    const session = await getServerSession(authOptions);

    if (!session) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Fetch locations
    const locations = await getLocationsByCity(params.cityId);

    return NextResponse.json(
      { success: true, data: locations },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error fetching locations:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch locations" },
      { status: 500 }
    );
  }
}


----- app\api\v1\[cityId]\payments\card-info\[customerId]\route.ts -----

// src/lib/services/stripe-customer-service.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Stripe customer payment method info ONLY
 */

import Stripe from "stripe";

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: "2025-09-30.clover",
});

export interface CardInfo {
  hasCard: boolean;
  brand?: string; // "visa", "mastercard", etc.
  last4?: string;
  expMonth?: number;
  expYear?: number;
  isExpired: boolean;
  isValid: boolean;
  paymentMethodId?: string;
}

/**
 * Get customer's default payment method info
 */
export async function getCustomerCardInfo(
  customerId: string
): Promise<CardInfo> {
  try {
    // Retrieve customer with expanded payment method
    const customer = await stripe.customers.retrieve(customerId, {
      expand: ["invoice_settings.default_payment_method"],
    });

    // Check if customer was deleted
    if (customer.deleted) {
      console.log("Customer was deleted:", customerId);
      return { hasCard: false, isExpired: false, isValid: false };
    }

    // Get default payment method
    const defaultPaymentMethod =
      customer.invoice_settings?.default_payment_method;

    if (!defaultPaymentMethod) {
      console.log("No default payment method for customer:", customerId);
      return { hasCard: false, isExpired: false, isValid: false };
    }

    // If it's just a string ID, we need to fetch the payment method
    let paymentMethod: Stripe.PaymentMethod;

    if (typeof defaultPaymentMethod === "string") {
      console.log("Fetching payment method:", defaultPaymentMethod);
      paymentMethod = await stripe.paymentMethods.retrieve(
        defaultPaymentMethod
      );
    } else {
      paymentMethod = defaultPaymentMethod;
    }

    // Check if it's a card
    if (paymentMethod.type !== "card" || !paymentMethod.card) {
      console.log("Payment method is not a card:", paymentMethod.type);
      return { hasCard: false, isExpired: false, isValid: false };
    }

    const card = paymentMethod.card;

    // Check if card is expired
    const now = new Date();
    const currentYear = now.getFullYear();
    const currentMonth = now.getMonth() + 1; // 0-indexed

    const isExpired =
      card.exp_year < currentYear ||
      (card.exp_year === currentYear && card.exp_month < currentMonth);

    console.log("Card info retrieved successfully:", {
      brand: card.brand,
      last4: card.last4,
      isExpired,
    });

    return {
      hasCard: true,
      brand: card.brand,
      last4: card.last4,
      expMonth: card.exp_month,
      expYear: card.exp_year,
      isExpired,
      isValid: !isExpired,
      paymentMethodId: paymentMethod.id,
    };
  } catch (error: any) {
    console.error("Error getting customer card info:", error.message);
    console.error("Full error:", error);
    return { hasCard: false, isExpired: false, isValid: false };
  }
}

/**
 * Charge customer's card
 */
export async function chargeCustomerCard({
  customerId,
  amount,
  description,
  metadata,
}: {
  customerId: string;
  amount: number;
  description: string;
  metadata: Record<string, string>;
}) {
  try {
    // Get customer to find default payment method
    const customer = await stripe.customers.retrieve(customerId);

    if (customer.deleted) {
      throw new Error("Customer not found");
    }

    const defaultPaymentMethod =
      customer.invoice_settings?.default_payment_method;

    if (!defaultPaymentMethod) {
      throw new Error("No payment method on file");
    }

    const paymentMethodId =
      typeof defaultPaymentMethod === "string"
        ? defaultPaymentMethod
        : defaultPaymentMethod.id;

    // Create and confirm payment intent
    const paymentIntent = await stripe.paymentIntents.create({
      amount,
      currency: "usd",
      customer: customerId,
      payment_method: paymentMethodId,
      confirm: true,
      description,
      metadata,
      off_session: true, // Indicate this is a merchant-initiated charge
      return_url: `${process.env.NEXT_PUBLIC_ADMIN_URL}/admin/payments`, // Required for off_session
    });

    return paymentIntent;
  } catch (error: any) {
    console.error("Error charging customer card:", error.message);
    throw error;
  }
}


----- app\api\v1\[cityId]\payments\charge-card\route.ts -----

// src/app/api/v1/[cityId]/payments/charge-card/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Charge customer card API ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { connectDB } from "@/lib/db/mongodb";
import { chargeCustomerCard } from "@/lib/services/stripe-customer-service";
import Player from "@/models/Player";
import PaymentMethod from "@/models/PaymentMethod";
import twilio from "twilio";

const twilioClient = twilio(
  process.env.TWILIO_ACCOUNT_SID,
  process.env.TWILIO_AUTH_TOKEN
);

/**
 * POST /api/v1/[cityId]/payments/charge-card
 * Charge customer's card on file
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_payments")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { playerId, paymentMethodId, paymentNumber, amount } =
      await request.json();

    await connectDB();

    // Get player with populated fields
    const player = await Player.findById(playerId)
      .populate("user", "name email phoneNumber")
      .populate("team", "teamName")
      .lean();

    if (!player || !player.customerId) {
      return NextResponse.json(
        { success: false, error: "Player not found or no Stripe customer" },
        { status: 404 }
      );
    }

    // Get payment method
    const paymentMethod = await PaymentMethod.findById(paymentMethodId).lean();

    if (!paymentMethod) {
      return NextResponse.json(
        { success: false, error: "Payment method not found" },
        { status: 404 }
      );
    }

    // Charge card via Stripe
    try {
      const paymentIntent = await chargeCustomerCard({
        customerId: player.customerId,
        amount,
        description: `${
          (player.team as any)?.teamName || "Team"
        } - Payment #${paymentNumber} - ${player.playerName}`,
        metadata: {
          playerId: player._id.toString(),
          paymentMethodId: paymentMethod._id.toString(),
          paymentNumber: paymentNumber.toString(),
          chargedBy: session.user?.email || "admin",
        },
      });

      if (paymentIntent.status !== "succeeded") {
        throw new Error(
          paymentIntent.last_payment_error?.message || "Payment failed"
        );
      }

      // Create new FULL_PAYMENT PaymentMethod for this installment
      const manualPayment = new PaymentMethod({
        paymentType: "FULL_PAYMENT",
        pricingTier: paymentMethod.pricingTier,
        originalPrice: amount / 100, // Convert back to dollars
        amountPaid: amount / 100,
        status: "COMPLETED",
        player: player._id,
        division: paymentMethod.division,
        isManualInstallment: true,
        installmentNumber: paymentNumber,
        replacedPaymentMethod: paymentMethod._id,
        stripePaymentIntentId: paymentIntent.id,
      });

      await manualPayment.save();

      // Add to player's payment methods
      await Player.findByIdAndUpdate(player._id, {
        $push: { paymentMethods: manualPayment._id },
      });

      // Mark original subscription payment as replaced
      await PaymentMethod.updateOne(
        {
          _id: paymentMethod._id,
          "installments.subscriptionPayments.paymentNumber": paymentNumber,
        },
        {
          $set: {
            "installments.subscriptionPayments.$.replacedBy": manualPayment._id,
          },
        }
      );

      // Send SMS confirmation to player
      const userPhone = (player.user as any)?.phoneNumber;
      if (userPhone) {
        try {
          await twilioClient.messages.create({
            body: `Hi ${
              player.playerName
            }, your payment #${paymentNumber} for $${
              amount / 100
            } has been processed successfully. You'll receive a receipt from Stripe via email.`,
            from: process.env.TWILIO_MESSAGING_SERVICE_SID,
            to: userPhone,
          });
        } catch (smsError) {
          console.error("Failed to send SMS confirmation:", smsError);
          // Don't fail the whole request if SMS fails
        }
      }

      return NextResponse.json(
        {
          success: true,
          data: {
            paymentIntentId: paymentIntent.id,
            manualPaymentId: manualPayment._id,
            amount: amount / 100,
          },
        },
        { status: 200 }
      );
    } catch (stripeError: any) {
      // Handle Stripe-specific errors
      return NextResponse.json(
        {
          success: false,
          error: stripeError.message || "Card charge failed",
        },
        { status: 400 }
      );
    }
  } catch (error: any) {
    console.error("Error charging card:", error);
    return NextResponse.json(
      { success: false, error: "Failed to charge card" },
      { status: 500 }
    );
  }
}


----- app\api\v1\[cityId]\payments\export\route.ts -----

// src/app/api/v1/[cityId]/payments/export/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Export payments to CSV ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getPlayersWithPaymentStatus } from "@/lib/db/queries/payments";

/**
 * POST /api/v1/[cityId]/payments/export
 * Export payment data to CSV
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "view_payments")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { filters } = await request.json();

    const players = await getPlayersWithPaymentStatus({
      cityId: params.cityId,
      locationId: filters?.location,
      divisionId: filters?.division,
      teamId: filters?.team,
      paymentStatusFilter: filters?.payment || "all",
      search: filters?.search,
    });

    // Create CSV content
    const headers = [
      "Player Name",
      "Email",
      "Phone",
      "Team",
      "Division",
      "Location",
      "Payment Status",
      "Payment Type",
      "Pricing Tier",
      "Registration Date",
      "Payments Completed",
      "Failed Payments",
    ];

    const rows = players.map((player: any) => {
      const paymentMethod = player.paymentMethod;
      let paymentsCompleted = "N/A";
      let failedPayments = "N/A";

      if (paymentMethod?.paymentType === "INSTALLMENTS") {
        const subscriptionPayments =
          paymentMethod.installments?.subscriptionPayments || [];
        const completed = subscriptionPayments.filter(
          (p: any) => p.status === "succeeded"
        ).length;
        const failed = subscriptionPayments.filter(
          (p: any) => p.status === "failed"
        ).length;
        paymentsCompleted = `${completed}/8`;
        failedPayments = failed.toString();
      }

      return [
        player.playerName,
        player.user?.email || "",
        player.user?.phoneNumber || "",
        player.team?.teamName || "No Team",
        player.division?.divisionName || "",
        player.division?.location?.name || "",
        player.paymentStatus,
        paymentMethod?.paymentType || "None",
        paymentMethod?.pricingTier || "N/A",
        player.createdAt ? new Date(player.createdAt).toLocaleDateString() : "",
        paymentsCompleted,
        failedPayments,
      ];
    });

    // Convert to CSV format
    const csvContent = [
      headers.join(","),
      ...rows.map((row) =>
        row.map((cell) => `"${String(cell).replace(/"/g, '""')}"`).join(",")
      ),
    ].join("\n");

    // Return as downloadable file
    return new NextResponse(csvContent, {
      status: 200,
      headers: {
        "Content-Type": "text/csv",
        "Content-Disposition": `attachment; filename="payment-report-${
          new Date().toISOString().split("T")[0]
        }.csv"`,
      },
    });
  } catch (error: any) {
    console.error("Error exporting payment data:", error);
    return NextResponse.json(
      { success: false, error: "Failed to export payment data" },
      { status: 500 }
    );
  }
}


----- app\api\v1\[cityId]\payments\route.ts -----

// src/app/api/v1/[cityId]/payments/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Payments API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getPlayersWithPaymentStatus } from "@/lib/db/queries/payments";

/**
 * GET /api/v1/[cityId]/payments
 * Get players with payment status
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "view_payments")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const locationId = searchParams.get("location") || undefined;
    const divisionId = searchParams.get("division") || undefined;
    const teamId = searchParams.get("team") || undefined;
    const paymentStatusFilter = searchParams.get("payment") || "all";
    const search = searchParams.get("search") || undefined;

    const players = await getPlayersWithPaymentStatus({
      cityId: params.cityId,
      locationId,
      divisionId,
      teamId,
      paymentStatusFilter,
      search,
    });

    return NextResponse.json(
      { success: true, data: players },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error fetching payment data:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch payment data" },
      { status: 500 }
    );
  }
}

----- app\api\v1\[cityId]\players\route.ts -----

// src/app/api/v1/[cityId]/players/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Players API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { getPlayers, createPlayer } from "@/lib/db/queries/players";
import { createPlayerSchema } from "@/lib/validations/player";
import { z } from "zod";

/**
 * GET /api/v1/[cityId]/players
 * Get players with filters
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "view_players")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1");
    const divisionId = searchParams.get("division") || undefined;
    const teamId = searchParams.get("team") || undefined;
    const paymentFilter = (searchParams.get("payment") as any) || "all";
    const freeAgentsOnly = searchParams.get("freeAgents") === "true";
    const hasUserAccount = searchParams.get("hasUser")
      ? searchParams.get("hasUser") === "true"
      : undefined;
    const search = searchParams.get("search") || undefined;

    const result = await getPlayers({
      cityId: params.cityId,
      page,
      divisionId,
      teamId,
      paymentFilter,
      freeAgentsOnly,
      hasUserAccount,
      search,
    });

    return NextResponse.json({ success: true, data: result }, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching players:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch players" },
      { status: 500 }
    );
  }
}

/**
 * POST /api/v1/[cityId]/players
 * Create player
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_players")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = createPlayerSchema.parse(body);

    const player = await createPlayer(validatedData);

    return NextResponse.json({ success: true, data: player }, { status: 201 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error creating player:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to create player" },
      { status: 500 }
    );
  }
}


----- app\api\v1\[cityId]\players\[id]\route.ts -----

// src/app/api/v1/[cityId]/players/[id]/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Single player API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { updatePlayer, deletePlayer } from "@/lib/db/queries/players";
import { updatePlayerSchema } from "@/lib/validations/player";
import { z } from "zod";

/**
 * PATCH /api/v1/[cityId]/players/[id]
 * Update player
 */
export async function PATCH(
  request: NextRequest,
  { params }: { params: { cityId: string; id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_players")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = updatePlayerSchema.parse(body);

    const { id, ...updateData } = validatedData;

    const player = await updatePlayer(params.id, updateData);

    if (!player) {
      return NextResponse.json(
        { success: false, error: "Player not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, data: player }, { status: 200 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error updating player:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to update player" },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/v1/[cityId]/players/[id]
 * Delete player
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: { cityId: string; id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_players")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    await deletePlayer(params.id);

    return NextResponse.json(
      { success: true, message: "Player deleted successfully" },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error deleting player:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to delete player" },
      { status: 500 }
    );
  }
}


----- app\api\v1\[cityId]\teams\route.ts -----

// src/app/api/v1/[cityId]/teams/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Teams API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import {
  getTeams,
  createTeam,
  updateTeam,
  deleteTeam,
  teamCodeExistsInDivision,
} from "@/lib/db/queries/teams";
import { createTeamSchema, updateTeamSchema } from "@/lib/validations/team";
import { z } from "zod";
import Team from "@/models/Team";

/**
 * GET /api/v1/[cityId]/teams
 * Get teams with pagination (EXECUTIVE + COMMISSIONER)
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "view_teams")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1");
    const paymentFilter = (searchParams.get("tab") as any) || "all";
    const divisionId = searchParams.get("division") || undefined;
    const locationId = searchParams.get("location") || undefined;
    const search = searchParams.get("search") || undefined;
    const viewMode = (searchParams.get("view") as any) || "card";

    const result = await getTeams({
      cityId: params.cityId,
      page,
      paymentFilter,
      divisionId,
      locationId,
      search,
      viewMode,
    });

    return NextResponse.json({ success: true, data: result }, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching teams:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch teams" },
      { status: 500 }
    );
  }
}

/**
 * POST /api/v1/[cityId]/teams
 * Create team (EXECUTIVE + COMMISSIONER)
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_teams")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = createTeamSchema.parse(body);

    // Check if team code exists in division
    const codeExists = await teamCodeExistsInDivision(
      validatedData.teamCode,
      validatedData.division
    );

    if (codeExists) {
      return NextResponse.json(
        { success: false, error: "Team code already exists in this division" },
        { status: 409 }
      );
    }

    const team = await createTeam(validatedData);

    return NextResponse.json({ success: true, data: team }, { status: 201 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error creating team:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to create team" },
      { status: 500 }
    );
  }
}

/**
 * PATCH /api/v1/[cityId]/teams
 * Update team (EXECUTIVE + COMMISSIONER)
 */
export async function PATCH(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_teams")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validatedData = updateTeamSchema.parse(body);

    const { id, ...updateData } = validatedData;

    // Check team code uniqueness if being updated
    if (updateData.teamCode && updateData.division) {
      const team = await Team.findById(id);
      const codeExists = await teamCodeExistsInDivision(
        updateData.teamCode,
        updateData.division,
        id
      );

      if (codeExists) {
        return NextResponse.json(
          {
            success: false,
            error: "Team code already exists in this division",
          },
          { status: 409 }
        );
      }
    }

    const team = await updateTeam(id, updateData);

    if (!team) {
      return NextResponse.json(
        { success: false, error: "Team not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, data: team }, { status: 200 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: "Validation failed", details: error.errors },
        { status: 400 }
      );
    }

    console.error("Error updating team:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to update team" },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/v1/[cityId]/teams
 * Delete team (EXECUTIVE + COMMISSIONER)
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_teams")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const teamId = searchParams.get("id");

    if (!teamId) {
      return NextResponse.json(
        { success: false, error: "Team ID is required" },
        { status: 400 }
      );
    }

    await deleteTeam(teamId);

    return NextResponse.json(
      { success: true, message: "Team deleted successfully" },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error deleting team:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to delete team" },
      { status: 500 }
    );
  }
}


----- app\api\v1\[cityId]\teams\[teamId]\roster\route.ts -----

// src/app/api/v1/[cityId]/teams/[teamId]/roster/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Team roster management API ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import {
  addPlayerToTeam,
  removePlayerFromTeam,
  getFreeAgentsByDivision,
} from "@/lib/db/queries/players";
import { getTeamById } from "@/lib/db/queries/teams";

/**
 * GET /api/v1/[cityId]/teams/[teamId]/roster
 * Get free agents for team's division
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { cityId: string; teamId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_teams")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const team = await getTeamById(params.teamId);

    if (!team) {
      return NextResponse.json(
        { success: false, error: "Team not found" },
        { status: 404 }
      );
    }

    const divisionId =
      typeof team.division === "object" ? team.division._id : team.division;

    const freeAgents = await getFreeAgentsByDivision(divisionId.toString());

    return NextResponse.json(
      { success: true, data: freeAgents },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error fetching free agents:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch free agents" },
      { status: 500 }
    );
  }
}

/**
 * POST /api/v1/[cityId]/teams/[teamId]/roster
 * Add player to team roster
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { cityId: string; teamId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_teams")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const { playerId } = body;

    if (!playerId) {
      return NextResponse.json(
        { success: false, error: "Player ID is required" },
        { status: 400 }
      );
    }

    await addPlayerToTeam(playerId, params.teamId);

    return NextResponse.json(
      { success: true, message: "Player added to team" },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error adding player to team:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to add player" },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/v1/[cityId]/teams/[teamId]/roster
 * Remove player from team roster
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: { cityId: string; teamId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_teams")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const playerId = searchParams.get("playerId");

    if (!playerId) {
      return NextResponse.json(
        { success: false, error: "Player ID is required" },
        { status: 400 }
      );
    }

    await removePlayerFromTeam(playerId, params.teamId);

    return NextResponse.json(
      { success: true, message: "Player removed from team" },
      { status: 200 }
    );
  } catch (error: any) {
    console.error("Error removing player from team:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Failed to remove player" },
      { status: 500 }
    );
  }
}


----- app\api\v1\[cityId]\users\search\route.ts -----

// src/app/api/v1/[cityId]/users/search/route.ts

/**
 * SOLID - Single Responsibility Principle (SRP)
 * User search API endpoint ONLY
 */

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth.config";
import { hasPermission } from "@/lib/auth/permissions";
import { connectDB } from "@/lib/db/mongodb";
import User from "@/models/User";

/**
 * GET /api/v1/[cityId]/users/search
 * Search users by email or name
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { cityId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !hasPermission(session, "manage_players")) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const query = searchParams.get("q");

    if (!query || query.length < 2) {
      return NextResponse.json(
        { success: false, error: "Query must be at least 2 characters" },
        { status: 400 }
      );
    }

    await connectDB();

    const users = await User.find({
      $or: [
        { email: { $regex: query, $options: "i" } },
        { name: { $regex: query, $options: "i" } },
      ],
    })
      .select("_id name email")
      .limit(10)
      .lean();

    return NextResponse.json({ success: true, data: users }, { status: 200 });
  } catch (error: any) {
    console.error("Error searching users:", error);
    return NextResponse.json(
      { success: false, error: "Failed to search users" },
      { status: 500 }
    );
  }
}


----- app\globals.css -----

/* src/app/globals.css */

/**
 * Global Styles
 * 
 * Performance Optimization:
 * - Tailwind JIT only includes used classes
 * 
 * Accessibility:
 * - Focus-visible for keyboard navigation
 */

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  * {
    @apply border-gray-200;
  }

  body {
    @apply bg-gray-50 text-gray-900;
  }
  :root {

    --background: 0 0% 100%;

    --foreground: 0 0% 3.9%;

    --card: 0 0% 100%;

    --card-foreground: 0 0% 3.9%;

    --popover: 0 0% 100%;

    --popover-foreground: 0 0% 3.9%;

    --primary: 0 0% 9%;

    --primary-foreground: 0 0% 98%;

    --secondary: 0 0% 96.1%;

    --secondary-foreground: 0 0% 9%;

    --muted: 0 0% 96.1%;

    --muted-foreground: 0 0% 45.1%;

    --accent: 0 0% 96.1%;

    --accent-foreground: 0 0% 9%;

    --destructive: 0 84.2% 60.2%;

    --destructive-foreground: 0 0% 98%;

    --border: 0 0% 89.8%;

    --input: 0 0% 89.8%;

    --ring: 0 0% 3.9%;

    --chart-1: 12 76% 61%;

    --chart-2: 173 58% 39%;

    --chart-3: 197 37% 24%;

    --chart-4: 43 74% 66%;

    --chart-5: 27 87% 67%;

    --radius: 0.5rem
  }
  .dark {

    --background: 0 0% 3.9%;

    --foreground: 0 0% 98%;

    --card: 0 0% 3.9%;

    --card-foreground: 0 0% 98%;

    --popover: 0 0% 3.9%;

    --popover-foreground: 0 0% 98%;

    --primary: 0 0% 98%;

    --primary-foreground: 0 0% 9%;

    --secondary: 0 0% 14.9%;

    --secondary-foreground: 0 0% 98%;

    --muted: 0 0% 14.9%;

    --muted-foreground: 0 0% 63.9%;

    --accent: 0 0% 14.9%;

    --accent-foreground: 0 0% 98%;

    --destructive: 0 62.8% 30.6%;

    --destructive-foreground: 0 0% 98%;

    --border: 0 0% 14.9%;

    --input: 0 0% 14.9%;

    --ring: 0 0% 83.1%;

    --chart-1: 220 70% 50%;

    --chart-2: 160 60% 45%;

    --chart-3: 30 80% 55%;

    --chart-4: 280 65% 60%;

    --chart-5: 340 75% 55%
  }
}

@layer utilities {
  /* Focus styles for accessibility */
  .focus-ring {
    @apply focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2;
  }

  /* Common button base */
  .btn-base {
    @apply px-4 py-2 rounded-lg font-medium transition-colors focus-ring disabled:opacity-50 disabled:cursor-not-allowed;
  }

  .btn-primary {
    @apply btn-base bg-blue-600 text-white hover:bg-blue-700;
  }

  .btn-secondary {
    @apply btn-base bg-gray-200 text-gray-900 hover:bg-gray-300;
  }

  /* Form inputs */
  .input {
    @apply w-full px-3 py-2 border border-gray-300 rounded-lg focus-ring;
  }

  .label {
    @apply block text-sm font-medium text-gray-700 mb-1;
  }

  /* Card */
  .card {
    @apply bg-white rounded-lg shadow-sm border border-gray-200;
  }
}



@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}


----- app\layout.tsx -----

// src/app/layout.tsx

/**
 * Next.js 14 Root Layout
 *
 * SOLID - Single Responsibility Principle (SRP)
 * Manages global HTML structure and providers ONLY
 */

import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { SessionProvider } from "@/components/providers/SessionProvider";
import { Toaster } from "@/components/ui/sonner";
const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Basketball League Admin",
  description: "Basketball league administration portal",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <SessionProvider>
          {children}
          <Toaster />
        </SessionProvider>
      </body>
    </html>
  );
}


----- app\login\page.tsx -----

// src/app/login/page.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Login page orchestration ONLY
 */

"use client";

import { useState } from "react";
import { signIn } from "next-auth/react";
import { useRouter, useSearchParams } from "next/navigation";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Loader2 } from "lucide-react";

const loginSchema = z.object({
  email: z.string().email("Please enter a valid email"),
  password: z.string().min(1, "Password is required"),
});

type LoginFormData = z.infer<typeof loginSchema>;

export default function LoginPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
  });

  const onSubmit = async (data: LoginFormData) => {
    setIsLoading(true);
    setError(null);

    try {
      const result = await signIn("admin-credentials", {
        email: data.email,
        password: data.password,
        redirect: false,
      });

      if (result?.error) {
        setError(result.error);
      } else {
        router.push("/admin");
        router.refresh();
      }
    } catch (err: any) {
      setError("An unexpected error occurred");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 px-4">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle className="text-2xl">Admin Login</CardTitle>
          <CardDescription>
            Enter your credentials to access the admin portal
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
            {error && (
              <div className="bg-red-50 border border-red-200 text-red-800 rounded-lg p-3 text-sm">
                {error}
              </div>
            )}

            <div>
              <Label htmlFor="email">Email</Label>
              <Input
                {...register("email")}
                id="email"
                type="email"
                placeholder="admin@example.com"
                disabled={isLoading}
              />
              {errors.email && (
                <p className="text-sm text-red-600 mt-1">
                  {errors.email.message}
                </p>
              )}
            </div>

            <div>
              <Label htmlFor="password">Password</Label>
              <Input
                {...register("password")}
                id="password"
                type="password"
                disabled={isLoading}
              />
              {errors.password && (
                <p className="text-sm text-red-600 mt-1">
                  {errors.password.message}
                </p>
              )}
            </div>

            <Button type="submit" className="w-full" disabled={isLoading}>
              {isLoading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Signing in...
                </>
              ) : (
                "Sign In"
              )}
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}


----- app\unauthorized\page.tsx -----

// src/app/unauthorized/page.tsx

/**
 * User Experience
 * Clear feedback for access denied
 */

import Link from "next/link";
import { ShieldAlert } from "lucide-react";
import { Button } from "@/components/ui/button";

export default function UnauthorizedPage() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 px-4">
      <div className="text-center">
        <ShieldAlert className="mx-auto h-12 w-12 text-red-500 mb-4" />
        <h1 className="text-2xl font-bold text-gray-900 mb-2">Access Denied</h1>
        <p className="text-gray-600 mb-6">
          You don't have permission to access this page.
        </p>
        <Button asChild>
          <Link href="/admin">Return to Dashboard</Link>
        </Button>
      </div>
    </div>
  );
}


----- components\common\EmptyState.tsx -----

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Empty state component ONLY
 */

import { LucideIcon } from "lucide-react";

interface EmptyStateProps {
  icon: LucideIcon;
  title: string;
  description?: string;
  action?: React.ReactNode;
}

export function EmptyState({
  icon: Icon,
  title,
  description,
  action,
}: EmptyStateProps) {
  return (
    <div className="flex flex-col items-center justify-center p-12 text-center">
      <Icon className="h-12 w-12 text-gray-400 mb-4" />
      <h3 className="text-lg font-semibold text-gray-900 mb-2">{title}</h3>
      {description && <p className="text-gray-600 mb-4">{description}</p>}
      {action}
    </div>
  );
}


----- components\common\ErrorState.tsx -----

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Error state component ONLY
 */

import { AlertCircle } from "lucide-react";
import { Button } from "@/components/ui/button";

interface ErrorStateProps {
  message?: string;
  onRetry?: () => void;
}

export function ErrorState({
  message = "Something went wrong",
  onRetry,
}: ErrorStateProps) {
  return (
    <div
      role="alert"
      className="flex flex-col items-center justify-center p-12 text-center"
    >
      <AlertCircle className="h-12 w-12 text-red-500 mb-4" />
      <h3 className="text-lg font-semibold mb-2">Error</h3>
      <p className="text-gray-600 mb-4">{message}</p>
      {onRetry && (
        <Button onClick={onRetry} variant="outline">
          Try Again
        </Button>
      )}
    </div>
  );
}


----- components\common\LoadingState.tsx -----

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Loading state component ONLY
 */

/**
 * Accessibility
 * Proper ARIA labels for screen readers
 */

import { Loader2 } from "lucide-react";

interface LoadingStateProps {
  message?: string;
}

export function LoadingState({ message = "Loading..." }: LoadingStateProps) {
  return (
    <div
      role="status"
      aria-live="polite"
      className="flex flex-col items-center justify-center p-12"
    >
      <Loader2 className="h-8 w-8 animate-spin text-blue-600 mb-3" />
      <p className="text-sm text-gray-600">{message}</p>
    </div>
  );
}


----- components\common\Pagination.tsx -----

// src/components/common/Pagination.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Pagination UI component ONLY
 */

"use client";

import { Button } from "@/components/ui/button";
import { ChevronLeft, ChevronRight } from "lucide-react";

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  total: number;
  limit: number;
  onPageChange: (page: number) => void;
}

export function Pagination({
  currentPage,
  totalPages,
  total,
  limit,
  onPageChange,
}: PaginationProps) {
  const startItem = (currentPage - 1) * limit + 1;
  const endItem = Math.min(currentPage * limit, total);

  return (
    <div className="flex flex-col sm:flex-row items-center justify-between gap-4 pt-4">
      <div className="text-sm text-gray-600">
        Showing {startItem}-{endItem} of {total} divisions
      </div>

      <div className="flex items-center gap-2">
        <Button
          variant="outline"
          size="sm"
          onClick={() => onPageChange(currentPage - 1)}
          disabled={currentPage === 1}
        >
          <ChevronLeft className="h-4 w-4 mr-1" />
          Previous
        </Button>

        <span className="text-sm px-4 py-2">
          Page {currentPage} of {totalPages}
        </span>

        <Button
          variant="outline"
          size="sm"
          onClick={() => onPageChange(currentPage + 1)}
          disabled={currentPage === totalPages}
        >
          Next
          <ChevronRight className="h-4 w-4 ml-1" />
        </Button>
      </div>
    </div>
  );
}


----- components\features\admins\AdminsTable.tsx -----

// src/components/features/admins/AdminsTable.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Display admins table ONLY
 */

"use client";

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { format } from "date-fns";

import { IAdmin } from "@/models/Admin";

interface AdminsTableProps {
  admins: IAdmin[];
  cityId: string;
}

export function AdminsTable({ admins, cityId }: AdminsTableProps) {
  const getRoleBadgeColor = (role: string) => {
    const colors = {
      EXECUTIVE: "bg-purple-100 text-purple-800",
      COMMISSIONER: "bg-blue-100 text-blue-800",
      SCOREKEEPER: "bg-green-100 text-green-800",
      PHOTOGRAPHER: "bg-orange-100 text-orange-800",
    };
    return colors[role as keyof typeof colors] || "bg-gray-100 text-gray-800";
  };

  return (
    <div className="bg-white rounded-lg shadow">
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead>Name</TableHead>
            <TableHead>Email</TableHead>
            <TableHead>Role</TableHead>
            <TableHead>Access</TableHead>
            <TableHead>Status</TableHead>
            <TableHead>Created</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {admins.map((admin) => (
            <TableRow key={admin._id}>
              <TableCell className="font-medium">{admin.name}</TableCell>
              <TableCell>{admin.email}</TableCell>
              <TableCell>
                <Badge className={getRoleBadgeColor(admin.role)}>
                  {admin.role}
                </Badge>
              </TableCell>
              <TableCell className="text-sm text-gray-600">
                {admin.allLocations
                  ? "All Locations"
                  : `${admin.assignedLocations?.length || 0} location(s)`}
              </TableCell>
              <TableCell>
                {admin.isActive ? (
                  <Badge
                    variant="outline"
                    className="bg-green-50 text-green-700"
                  >
                    Active
                  </Badge>
                ) : (
                  <Badge variant="outline" className="bg-gray-50 text-gray-700">
                    Inactive
                  </Badge>
                )}
              </TableCell>
              <TableCell className="text-sm text-gray-600">
                {format(new Date(admin.createdAt), "MMM dd, yyyy")}
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}


----- components\features\admins\CreateAdminForm.tsx -----

// src/components/features/admins/CreateAdminForm.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Admin creation form ONLY
 */

// src/components/features/admins/CreateAdminForm.tsx

"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Checkbox } from "@/components/ui/checkbox";
import { Loader2 } from "lucide-react";
import { toast } from "sonner";
import { ILocation } from "@/models/Location";

const createAdminSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Invalid email address"),
  password: z
    .string()
    .min(8, "Password must be at least 8 characters")
    .regex(/[A-Z]/, "Must contain uppercase letter")
    .regex(/[a-z]/, "Must contain lowercase letter")
    .regex(/[0-9]/, "Must contain number"),
  phoneNumber: z.string().optional(),
});

type CreateAdminFormData = z.infer<typeof createAdminSchema>;

interface CreateAdminFormProps {
  locations: ILocation[];
  cityId: string;
}

export function CreateAdminForm({ locations, cityId }: CreateAdminFormProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [selectedRole, setSelectedRole] = useState<string>("");
  const [selectedLocations, setSelectedLocations] = useState<string[]>([]);

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<CreateAdminFormData>({
    resolver: zodResolver(createAdminSchema),
  });

  const needsLocationAssignment =
    selectedRole === "SCOREKEEPER" || selectedRole === "PHOTOGRAPHER";

  const onSubmit = async (data: CreateAdminFormData) => {
    if (!selectedRole) {
      toast.error("Please select a role");
      return;
    }

    if (needsLocationAssignment && selectedLocations.length === 0) {
      toast.error("Please select at least one location");
      return;
    }

    setIsLoading(true);

    try {
      const response = await fetch("/api/v1/admins", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          ...data,
          role: selectedRole,
          assignedLocations: needsLocationAssignment
            ? selectedLocations
            : undefined,
        }),
      });

      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.error || "Failed to create admin");
      }

      toast.success("Admin created successfully!");
      router.push(`/admin/${cityId}/settings/admins`);
      router.refresh();
    } catch (err: any) {
      toast.error(err.message || "Failed to create admin");
      console.error("Create admin error:", err);
    } finally {
      setIsLoading(false);
    }
  };

  const toggleLocation = (locationId: string) => {
    setSelectedLocations((prev) =>
      prev.includes(locationId)
        ? prev.filter((id) => id !== locationId)
        : [...prev, locationId]
    );
  };

  return (
    <form
      onSubmit={handleSubmit(onSubmit)}
      className="space-y-6 bg-white p-6 rounded-lg shadow"
    >
      <div className="grid gap-6 md:grid-cols-2">
        <div>
          <Label htmlFor="name">Full Name *</Label>
          <Input {...register("name")} id="name" disabled={isLoading} />
          {errors.name && (
            <p className="text-sm text-red-600 mt-1">{errors.name.message}</p>
          )}
        </div>

        <div>
          <Label htmlFor="email">Email *</Label>
          <Input
            {...register("email")}
            id="email"
            type="email"
            disabled={isLoading}
          />
          {errors.email && (
            <p className="text-sm text-red-600 mt-1">{errors.email.message}</p>
          )}
        </div>

        <div>
          <Label htmlFor="password">Password *</Label>
          <Input
            {...register("password")}
            id="password"
            type="password"
            disabled={isLoading}
          />
          {errors.password && (
            <p className="text-sm text-red-600 mt-1">
              {errors.password.message}
            </p>
          )}
        </div>

        <div>
          <Label htmlFor="phoneNumber">Phone Number</Label>
          <Input
            {...register("phoneNumber")}
            id="phoneNumber"
            disabled={isLoading}
          />
        </div>
      </div>

      <div>
        <Label htmlFor="role">Role *</Label>
        <Select
          value={selectedRole}
          onValueChange={setSelectedRole}
          disabled={isLoading}
        >
          <SelectTrigger>
            <SelectValue placeholder="Select role" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="EXECUTIVE">Executive</SelectItem>
            <SelectItem value="COMMISSIONER">Commissioner</SelectItem>
            <SelectItem value="SCOREKEEPER">Scorekeeper</SelectItem>
            <SelectItem value="PHOTOGRAPHER">Photographer</SelectItem>
          </SelectContent>
        </Select>
        {!selectedRole && (
          <p className="text-sm text-gray-600 mt-1">Please select a role</p>
        )}
        {selectedRole && (
          <p className="text-sm text-gray-600 mt-1">
            {selectedRole === "EXECUTIVE" || selectedRole === "COMMISSIONER"
              ? "Full access to all locations"
              : "Must assign specific locations"}
          </p>
        )}
      </div>

      {needsLocationAssignment && (
        <div>
          <Label>Assigned Locations *</Label>
          <div className="mt-2 space-y-2 border rounded-lg p-4 max-h-48 overflow-y-auto">
            {locations.length === 0 ? (
              <p className="text-sm text-gray-500">
                No locations available in this city
              </p>
            ) : (
              locations.map((location) => (
                <div key={location._id} className="flex items-center space-x-2">
                  <Checkbox
                    id={location._id}
                    checked={selectedLocations.includes(location._id)}
                    onCheckedChange={() => toggleLocation(location._id)}
                  />
                  <label
                    htmlFor={location._id}
                    className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer"
                  >
                    {location.name}
                  </label>
                </div>
              ))
            )}
          </div>
          {selectedLocations.length === 0 && (
            <p className="text-sm text-red-600 mt-1">
              Please select at least one location
            </p>
          )}
        </div>
      )}

      <div className="flex gap-4">
        <Button type="submit" disabled={isLoading || !selectedRole}>
          {isLoading ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              Creating...
            </>
          ) : (
            "Create Admin"
          )}
        </Button>
        <Button
          type="button"
          variant="outline"
          onClick={() => router.back()}
          disabled={isLoading}
        >
          Cancel
        </Button>
      </div>
    </form>
  );
}


----- components\features\dashboard\DashboardStats.tsx -----

// src/components/features/dashboard/DashboardStats.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Display dashboard stats ONLY
 */

"use client";

import { Card, CardContent } from "@/components/ui/card";
import { Users, Trophy, Calendar, MapPin } from "lucide-react";

interface DashboardStatsProps {
  stats: {
    divisions: number;
    teams: number;
    players: number;
    games: number;
  };
}

export function DashboardStats({ stats }: DashboardStatsProps) {
  const cards = [
    {
      label: "Active Divisions",
      value: stats.divisions,
      icon: MapPin,
      color: "text-blue-600",
    },
    {
      label: "Total Teams",
      value: stats.teams,
      icon: Trophy,
      color: "text-green-600",
    },
    {
      label: "Registered Players",
      value: stats.players,
      icon: Users,
      color: "text-purple-600",
    },
    {
      label: "Scheduled Games",
      value: stats.games,
      icon: Calendar,
      color: "text-orange-600",
    },
  ];

  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
      {cards.map((card) => (
        <Card key={card.label}>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">
                  {card.label}
                </p>
                <p className="text-3xl font-bold mt-2">{card.value}</p>
              </div>
              <card.icon className={`h-8 w-8 ${card.color}`} />
            </div>
          </CardContent>
        </Card>
      ))}
    </div>
  );
}


----- components\features\dashboard\UpcomingGames.tsx -----

// src/components/features/dashboard/UpcomingGames.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Display upcoming games ONLY
 */

"use client";

import Link from "next/link";
import { format } from "date-fns";
import { Calendar } from "lucide-react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { EmptyState } from "@/components/common/EmptyState";

interface Game {
  _id: string;
  date: Date;
  time: string;
  homeTeam: { teamName: string };
  awayTeam: { teamName: string };
  location: string;
}

interface UpcomingGamesProps {
  games: Game[];
  cityId: string;
}

export function UpcomingGames({ games, cityId }: UpcomingGamesProps) {
  if (games.length === 0) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Upcoming Games</CardTitle>
        </CardHeader>
        <CardContent>
          <EmptyState
            icon={Calendar}
            title="No upcoming games"
            description="There are no scheduled games at the moment"
          />
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Upcoming Games</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {games.map((game) => (
            <Link
              key={game._id}
              href={`/admin/${cityId}/games/${game._id}`}
              className="block p-3 rounded-lg hover:bg-gray-50 transition-colors"
            >
              <div className="font-medium">
                {game.homeTeam.teamName} vs {game.awayTeam.teamName}
              </div>
              <div className="flex items-center gap-4 mt-2 text-sm text-gray-600">
                <span>{format(new Date(game.date), "MMM dd, yyyy")}</span>
                <span>{game.time}</span>
                <Badge variant="outline">Upcoming</Badge>
              </div>
            </Link>
          ))}
        </div>
      </CardContent>
    </Card>
  );
}


----- components\features\league\cities\CitiesTable.tsx -----

// src/components/features/league/cities/CitiesTable.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Display cities table ONLY
 */

"use client";

import { useState } from "react";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { MoreHorizontal, Pencil, Trash2 } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { DeleteCityDialog } from "./DeleteCityDialog";
import { EditCityDialog } from "./EditCityDialog";
import { toast } from "sonner";
import { ICity } from "@/models/City";

interface CitiesTableProps {
  cities: ICity[];
  cityId: string;
}

export function CitiesTable({ cities, cityId }: CitiesTableProps) {
  console.log("cities:",cities)
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [editDialogOpen, setEditDialogOpen] = useState(false);
  const [selectedCity, setSelectedCity] = useState<ICity | null>(null);

  const handleDelete = (city: ICity) => {
    setSelectedCity(city);
    setDeleteDialogOpen(true);
  };

  const handleEdit = (city: ICity) => {
    setSelectedCity(city);
    setEditDialogOpen(true);
  };

  const handleToggleActive = async (city: ICity) => {
    try {
      const response = await fetch("/api/v1/league/cities", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          id: city._id,
          active: !city.active,
        }),
      });

      if (!response.ok) throw new Error("Failed to update city");

      toast.success(`City ${city.active ? "deactivated" : "activated"}`);
      window.location.reload();
    } catch (error) {
      toast.error("Failed to update city status");
    }
  };

  return (
    <>
      <div className="bg-white rounded-lg shadow">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>City</TableHead>
              <TableHead>Region</TableHead>
              <TableHead>Country</TableHead>
              <TableHead>Timezone</TableHead>
              <TableHead>Locations</TableHead>
              <TableHead>Status</TableHead>
              <TableHead className="w-[70px]"></TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {cities.length === 0 ? (
              <TableRow>
                <TableCell
                  colSpan={7}
                  className="text-center py-8 text-gray-500"
                >
                  No cities found. Create your first city to get started.
                </TableCell>
              </TableRow>
            ) : (
              cities.map((city) => (
                <TableRow key={city._id}>
                  <TableCell className="font-medium">{city.cityName}</TableCell>
                  <TableCell>{city.region}</TableCell>
                  <TableCell>{city.country}</TableCell>
                  <TableCell className="text-sm text-gray-600">
                    {city.timezone}
                  </TableCell>
                  <TableCell className="text-sm text-gray-600">
                    {city.locations.length} location(s)
                  </TableCell>
                  <TableCell>
                    {city.active ? (
                      <Badge
                        variant="outline"
                        className="bg-green-50 text-green-700 border-green-200"
                      >
                        Active
                      </Badge>
                    ) : (
                      <Badge
                        variant="outline"
                        className="bg-gray-50 text-gray-700"
                      >
                        Inactive
                      </Badge>
                    )}
                  </TableCell>
                  <TableCell>
                    <DropdownMenu>
                      <DropdownMenuTrigger asChild>
                        <Button variant="ghost" size="icon">
                          <MoreHorizontal className="h-4 w-4" />
                        </Button>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="end">
                        <DropdownMenuItem onClick={() => handleEdit(city)}>
                          <Pencil className="mr-2 h-4 w-4" />
                          Edit
                        </DropdownMenuItem>
                        <DropdownMenuItem
                          onClick={() => handleToggleActive(city)}
                        >
                          {city.active ? "Deactivate" : "Activate"}
                        </DropdownMenuItem>
                        <DropdownMenuItem
                          onClick={() => handleDelete(city)}
                          className="text-red-600"
                        >
                          <Trash2 className="mr-2 h-4 w-4" />
                          Delete
                        </DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>

      {selectedCity && (
        <>
          <DeleteCityDialog
            city={selectedCity}
            open={deleteDialogOpen}
            onOpenChange={setDeleteDialogOpen}
          />
          <EditCityDialog
            city={selectedCity}
            open={editDialogOpen}
            onOpenChange={setEditDialogOpen}
          />
        </>
      )}
    </>
  );
}


----- components\features\league\cities\CreateCityForm.tsx -----

// src/components/features/league/cities/CreateCityForm.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * City creation form ONLY
 */

"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Loader2 } from "lucide-react";
import { toast } from "sonner";
import { createCitySchema, CreateCityInput } from "@/lib/validations/city";

const TIMEZONES = [
  "America/New_York",
  "America/Chicago",
  "America/Denver",
  "America/Los_Angeles",
  "America/Toronto",
  "America/Vancouver",
  "Europe/London",
  "Europe/Paris",
  "Asia/Tokyo",
  "Australia/Sydney",
];

interface CreateCityFormProps {
  cityId: string;
}

export function CreateCityForm({ cityId }: CreateCityFormProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);

  const {
    register,
    handleSubmit,
    formState: { errors },
    setValue,
    watch,
  } = useForm<CreateCityInput>({
    resolver: zodResolver(createCitySchema),
  });

  const selectedTimezone = watch("timezone");

  const onSubmit = async (data: CreateCityInput) => {
    setIsLoading(true);

    try {
      const response = await fetch("/api/v1/league/cities", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.error || "Failed to create city");
      }

      toast.success("City created successfully!");
      router.push(`/admin/${cityId}/league/cities`);
      router.refresh();
    } catch (err: any) {
      toast.error(err.message || "Failed to create city");
      console.error("Create city error:", err);
    } finally {
      setIsLoading(false);
    }
  };

  const onError = (errors: any) => {
    console.log("Form validation errors:", errors);
    toast.error("Please fill in all required fields");
  };

  return (
    <form
      onSubmit={handleSubmit(onSubmit, onError)}
      className="space-y-6 bg-white p-6 rounded-lg shadow"
    >
      <div className="grid gap-6 md:grid-cols-2">
        <div>
          <Label htmlFor="cityName">City Name *</Label>
          <Input
            {...register("cityName")}
            id="cityName"
            placeholder="Toronto"
            disabled={isLoading}
          />
          {errors.cityName && (
            <p className="text-sm text-red-600 mt-1">
              {errors.cityName.message}
            </p>
          )}
        </div>

        <div>
          <Label htmlFor="region">Region/State *</Label>
          <Input
            {...register("region")}
            id="region"
            placeholder="Ontario"
            disabled={isLoading}
          />
          {errors.region && (
            <p className="text-sm text-red-600 mt-1">{errors.region.message}</p>
          )}
        </div>

        <div>
          <Label htmlFor="country">Country *</Label>
          <Input
            {...register("country")}
            id="country"
            placeholder="Canada"
            disabled={isLoading}
          />
          {errors.country && (
            <p className="text-sm text-red-600 mt-1">
              {errors.country.message}
            </p>
          )}
        </div>

        <div>
          <Label htmlFor="timezone">Timezone *</Label>
          <Select
            value={selectedTimezone}
            onValueChange={(value) =>
              setValue("timezone", value, { shouldValidate: true })
            }
            disabled={isLoading}
          >
            <SelectTrigger>
              <SelectValue placeholder="Select timezone" />
            </SelectTrigger>
            <SelectContent>
              {TIMEZONES.map((tz) => (
                <SelectItem key={tz} value={tz}>
                  {tz}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
          {errors.timezone && (
            <p className="text-sm text-red-600 mt-1">
              {errors.timezone.message}
            </p>
          )}
        </div>
      </div>

      <div className="flex gap-4">
        <Button type="submit" disabled={isLoading}>
          {isLoading ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              Creating...
            </>
          ) : (
            "Create City"
          )}
        </Button>
        <Button
          type="button"
          variant="outline"
          onClick={() => router.back()}
          disabled={isLoading}
        >
          Cancel
        </Button>
      </div>
    </form>
  );
}


----- components\features\league\cities\DeleteCityDialog.tsx -----

// src/components/features/league/cities/DeleteCityDialog.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Delete city confirmation dialog ONLY
 */

"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import {
  AlertDialog,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";
import { Loader2 } from "lucide-react";
import { toast } from "sonner";
import { ICity } from "@/models/City";

interface DeleteCityDialogProps {
  city: ICity;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function DeleteCityDialog({
  city,
  open,
  onOpenChange,
}: DeleteCityDialogProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);

  const handleDelete = async () => {
    setIsLoading(true);

    try {
      const response = await fetch(`/api/v1/league/cities?id=${city._id}`, {
        method: "DELETE",
      });

      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.error || "Failed to delete city");
      }

      toast.success("City deleted successfully");
      onOpenChange(false);
      router.refresh();
    } catch (err: any) {
      toast.error(err.message || "Failed to delete city");
      console.error("Delete city error:", err);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <AlertDialog open={open} onOpenChange={onOpenChange}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Delete City</AlertDialogTitle>
          <AlertDialogDescription>
            Are you sure you want to delete{" "}
            <span className="font-semibold">
              {city.cityName}, {city.region}, {city.country}
            </span>
            ? This action cannot be undone.
            <br />
            <br />
            Note: Existing divisions, teams, and games will not be affected.
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <Button
            variant="outline"
            onClick={() => onOpenChange(false)}
            disabled={isLoading}
          >
            Cancel
          </Button>
          <Button
            variant="destructive"
            onClick={handleDelete}
            disabled={isLoading}
          >
            {isLoading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Deleting...
              </>
            ) : (
              "Delete City"
            )}
          </Button>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}


----- components\features\league\cities\EditCityDialog.tsx -----

// src/components/features/league/cities/EditCityDialog.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Edit city dialog ONLY
 */

"use client";

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Loader2 } from "lucide-react";
import { toast } from "sonner";
import { createCitySchema, CreateCityInput } from "@/lib/validations/city";
import { ICity } from "@/models/City";

const TIMEZONES = [
  "America/New_York",
  "America/Chicago",
  "America/Denver",
  "America/Los_Angeles",
  "America/Toronto",
  "America/Vancouver",
  "Europe/London",
  "Europe/Paris",
  "Asia/Tokyo",
  "Australia/Sydney",
];

interface EditCityDialogProps {
  city: ICity;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function EditCityDialog({
  city,
  open,
  onOpenChange,
}: EditCityDialogProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [selectedTimezone, setSelectedTimezone] = useState<string>(
    city.timezone
  );

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<CreateCityInput>({
    resolver: zodResolver(createCitySchema),
    defaultValues: {
      cityName: city.cityName,
      region: city.region,
      country: city.country,
      timezone: city.timezone,
    },
  });

  useEffect(() => {
    if (open) {
      reset({
        cityName: city.cityName,
        region: city.region,
        country: city.country,
        timezone: city.timezone,
      });
      setSelectedTimezone(city.timezone);
    }
  }, [open, city, reset]);

  const onSubmit = async (data: CreateCityInput) => {
    setIsLoading(true);

    try {
      const response = await fetch("/api/v1/league/cities", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          id: city._id,
          ...data,
          timezone: selectedTimezone,
        }),
      });

      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.error || "Failed to update city");
      }

      toast.success("City updated successfully!");
      onOpenChange(false);
      router.refresh();
    } catch (err: any) {
      toast.error(err.message || "Failed to update city");
      console.error("Update city error:", err);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Edit City</DialogTitle>
          <DialogDescription>Update city information</DialogDescription>
        </DialogHeader>

        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          <div>
            <Label htmlFor="edit-cityName">City Name *</Label>
            <Input
              {...register("cityName")}
              id="edit-cityName"
              disabled={isLoading}
            />
            {errors.cityName && (
              <p className="text-sm text-red-600 mt-1">
                {errors.cityName.message}
              </p>
            )}
          </div>

          <div>
            <Label htmlFor="edit-region">Region/State *</Label>
            <Input
              {...register("region")}
              id="edit-region"
              disabled={isLoading}
            />
            {errors.region && (
              <p className="text-sm text-red-600 mt-1">
                {errors.region.message}
              </p>
            )}
          </div>

          <div>
            <Label htmlFor="edit-country">Country *</Label>
            <Input
              {...register("country")}
              id="edit-country"
              disabled={isLoading}
            />
            {errors.country && (
              <p className="text-sm text-red-600 mt-1">
                {errors.country.message}
              </p>
            )}
          </div>

          <div>
            <Label htmlFor="edit-timezone">Timezone *</Label>
            <Select
              value={selectedTimezone}
              onValueChange={setSelectedTimezone}
              disabled={isLoading}
            >
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {TIMEZONES.map((tz) => (
                  <SelectItem key={tz} value={tz}>
                    {tz}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="flex gap-4 justify-end">
            <Button
              type="button"
              variant="outline"
              onClick={() => onOpenChange(false)}
              disabled={isLoading}
            >
              Cancel
            </Button>
            <Button type="submit" disabled={isLoading}>
              {isLoading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Saving...
                </>
              ) : (
                "Save Changes"
              )}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}


----- components\features\league\divisions\CreateDivisionForm.tsx -----

// src/components/features/league/divisions/CreateDivisionForm.tsx

/**
 * SOLID - Single Responsibility Principle (SRP)
 * Division creation form ONLY
 */

"use client";

import { useState, useMemo } from "react";
import { useRouter } from "next/navigation";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Loader2, AlertCircle, Info } from "lucide-react";
import { toast } from "sonner";
import {
  createDivisionSchema,
  CreateDivisionInput,
} from "@/lib/validations/division";
import { format, subDays } from "date-fns";

interface City {
  _id: string;
  cityName: string;
  region: string;
  locations: any[];
}

interface Level {
  _id: string;
  name: string;
  grade: number;
}

interface Price {
  _id: string;
  name: string;
  amount: number;
  type: string;
}

interface CreateDivisionFormProps {
  cityId: string;
  cities: City[];
  levels: Level[];
  prices: Price[];
}

export function CreateDivisionForm({
  cityId,
  cities,
  levels,
  prices,
}: CreateDivisionFormProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [selectedCity, setSelectedCity] = useState(cityId);
  const [selectedStartDate, setSelectedStartDate] = useState<string>("");
  const [conflictWarning, setConflictWarning] = useState<string | null>(null);

  const {
    register,
    handleSubmit,
    formState: { errors },
    setValue,
    watch,
  } = useForm<CreateDivisionInput>({
    resolver: zodResolver(createDivisionSchema),
    defaultValues: {
      city: cityId,
      active: false,
      register: false,
    },
  });

  const selectedLocation = watch("location");
  const selectedLevel = watch("level");
  const selectedDay = watch("day");
  const active = watch("active");
  const registerOpen = watch("register");

  // Filter locations by selected city
  const availableLocations = useMemo(() => {
    const city = cities.find((c) => c._id === selectedCity);
    return city?.locations || [];
  }, [cities, selectedCity]);

  // Filter prices by type
  const pricesByType = useMemo(() => {
    return {
      earlyBird: prices.filter((p) => p.type === "earlyBird"),
      regular: prices.filter((p) => p.type === "regular"),
      installment: prices.filter((p) => p.type === "installment"),
      regularInstallment: prices.filter((p) => p.type === "regularInstallment"),
      firstInstallment: prices.filter((p) => p.type === "firstInstallment"),
      free: prices.filter((p) => p.type === "free"),
    };
  }, [prices]);

  // Calculate early bird end date
  const earlyBirdEndDate = useMemo(() => {
    if (!selectedStartDate) return null;
    const startDate = new Date(selectedStartDate);
    return subDays(startDate, 42);
  }, [selectedStartDate]);

  const onSubmit = async (data: CreateDivisionInput) => {
    setIsLoading(true);
    setConflictWarning(null);

    try {
      const response = await fetch(`/api/v1/${cityId}/divisions`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.error || "Failed to create division");
      }

      // Show conflict warning if exists
      if (result.warning) {
        setConflictWarning(result.warning.message);
      }

      toast.success("Division created successfully!");
      router.push(`/admin/${cityId}/league/divisions`);
      router.refresh();
    } catch (err: any) {
      toast.error(err.message || "Failed to create division");
      console.error("Create division error:", err);
    } finally {
      setIsLoading(false);
    }
  };

  const onError = (errors: any) => {
    console.log("Form validation errors:", errors);
    toast.error("Please fill in all required fields");
  };

  return (
    <form onSubmit={handleSubmit(onSubmit, onError)} className="space-y-6">
      {/* Basic Information */}
      <Card>
        <CardHeader>
          <CardTitle>Basic Information</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div>
            <Label htmlFor="divisionName">Division Name *</Label>
            <Input
              {...register("divisionName")}
              id="divisionName"
              placeholder="Monday A Division - Elite"
              disabled={isLoading}
            />
            {errors.divisionName && (
              <p className="text-sm text-red-600 mt-1">
                {errors.divisionName.message}
              </p>
            )}
          </div>

          <div>
            <Label htmlFor="description">Description *</Label>
            <Textarea
              {...register("description")}
              id="description"
              placeholder="Competitive league for experienced players..."
              rows={3}
              disabled={isLoading}
            />
            {errors.description && (
              <p className="text-sm text-red-600 mt-1">
                {errors.description.message}
              </p>
            )}
          </div>
        </CardContent>
      </Card>

      {/* Location & Level */}
      <Card>
        <CardHeader>
          <CardTitle>Location & Level</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div>
            <Label htmlFor="city">City *</Label>
            <Select
              value={selectedCity}
              onValueChange={(value) => {
                setSelectedCity(value);
                setValue("city", value, { shouldValidate: true });
                setValue("location", "", { shouldValidate: false });
              }}
              disabled={isLoading}
            >
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {cities.map((city) => (
                  <SelectItem key={city._id} value={city._id}>
                    {city.cityName}, {city.region}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            {errors.city && (
              <p className="text-sm text-red-600 mt-1">{errors.city.message}</p>
            )}
          </div>

          <div>
            <Label htmlFor="location">Location *</Label>
            <Select
              value={selectedLocation}
              onValueChange={(value) =>
                setValue("location", value, { shouldValidate: true })
              }
              disabled={isLoading || availableLocations.length === 0}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select location" />
              </SelectTrigger>
              <SelectContent>
                {availableLocations.map((location: any) => (
                  <SelectItem
                    key={location._id || location}
                    value={location._id || location}
                  >
                    {location.name || "Location"}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            {errors.location && (
              <p className="text-sm text-red-600 mt-1">
                {errors.location.message}
              </p>
            )}
            {conflictWarning && (
              <div className="flex items-start gap-2 mt-2 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
                <AlertCircle className="h-5 w-5 text-yellow-600 flex-shrink-0 mt-0.5" />
                <p className="text-sm text-yellow-800">{conflictWarning}</p>
              </div>
            )}
          </div>

          <div>
            <Label htmlFor="level">Skill Level *</Label>
            <Select
              value={selectedLevel}
              onValueChange={(value) =>
                setValue("level", value, { shouldValidate: true })
              }
              disabled={isLoading}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select level" />
              </SelectTrigger>
              <SelectContent>
                {levels.map((level) => (
                  <SelectItem key={level._id} value={level._id}>
                    Grade {level.grade} - {level.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            {errors.level && (
              <p className="text-sm text-red-600 mt-1">
                {errors.level.message}
              </p>
            )}
          </div>
        </CardContent>
      </Card>

      {/* Schedule */}
      <Card>
        <CardHeader>
          <CardTitle>Schedule</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div>
            <Label htmlFor="day">Day *</Label>
            <Select
              value={selectedDay}
              onValueChange={(value) =>
                setValue("day", value as any, { shouldValidate: true })
              }
              disabled={isLoading}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select day" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="Monday">Monday</SelectItem>
                <SelectItem value="Tuesday">Tuesday</SelectItem>
                <SelectItem value="Wednesday">Wednesday</SelectItem>
                <SelectItem value="Thursday">Thursday</SelectItem>
                <SelectItem value="Friday">Friday</SelectItem>
                <SelectItem value="Saturday">Saturday</SelectItem>
                <SelectItem value="Sunday">Sunday</SelectItem>
              </SelectContent>
            </Select>
            {errors.day && (
              <p className="text-sm text-red-600 mt-1">{errors.day.message}</p>
            )}
          </div>

          <div className="grid gap-4 md:grid-cols-3">
            <div>
              <Label htmlFor="startDate">Start Date</Label>
              <Input
                {...register("startDate")}
                id="startDate"
                type="date"
                disabled={isLoading}
                onChange={(e) => {
                  setSelectedStartDate(e.target.value);
                  setValue("startDate", e.target.value);
                }}
              />
            </div>

            <div>
              <Label htmlFor="startTime">Start Time</Label>
              <Input
                {...register("startTime")}
                id="startTime"
                type="time"
                disabled={isLoading}
              />
            </div>

            <div>
              <Label htmlFor="endTime">End Time</Label>
              <Input
                {...register("endTime")}
                id="endTime"
                type="time"
                disabled={isLoading}
              />
            </div>
          </div>

          {earlyBirdEndDate && (
            <div className="flex items-start gap-2 p-3 bg-blue-50 border border-blue-200 rounded-lg">
              <Info className="h-5 w-5 text-blue-600 flex-shrink-0 mt-0.5" />
              <p className="text-sm text-blue-800">
                Early bird pricing ends 42 days (6 weeks) before start date on{" "}
                <strong>{format(earlyBirdEndDate, "MMM dd, yyyy")}</strong>
              </p>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Pricing */}
      <Card>
        <CardHeader>
          <CardTitle>Pricing</CardTitle>
          <p className="text-sm text-gray-600">
            All pricing options are required and cannot be changed later
          </p>
        </CardHeader>
        <CardContent className="space-y-6">
          {/* Single Payment */}
          <div>
            <h4 className="font-medium mb-3">Single Payment Options</h4>
            <div className="grid gap-4 md:grid-cols-2">
              <div>
                <Label htmlFor="earlyBird">Early Bird Price *</Label>
                <Select
                  onValueChange={(value) =>
                    setValue("prices.earlyBird", value, {
                      shouldValidate: true,
                    })
                  }
                  disabled={isLoading}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select price" />
                  </SelectTrigger>
                  <SelectContent>
                    {pricesByType.earlyBird.map((price) => (
                      <SelectItem key={price._id} value={price._id}>
                        ${price.amount.toFixed(2)} - {price.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                {errors.prices?.earlyBird && (
                  <p className="text-sm text-red-600 mt-1">
                    {errors.prices.earlyBird.message}
                  </p>
                )}
              </div>

              <div>
                <Label htmlFor="regular">Regular Price *</Label>
                <Select
                  onValueChange={(value) =>
                    setValue("prices.regular", value, { shouldValidate: true })
                  }
                  disabled={isLoading}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select price" />
                  </SelectTrigger>
                  <SelectContent>
                    {pricesByType.regular.map((price) => (
                      <SelectItem key={price._id} value={price._id}>
                        ${price.amount.toFixed(2)} - {price.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                {errors.prices?.regular && (
                  <p className="text-sm text-red-600 mt-1">
                    {errors.prices.regular.message}
                  </p>
                )}
              </div>
            </div>
          </div>

          {/* Installment Payment */}
          <div>
            <h4 className="font-medium mb-3">Installment Payment Options</h4>
            <div className="grid gap-4 md:grid-cols-3">
              <div>
                <Label htmlFor="firstInstallment">Down Payment *</Label>
                <Select
                  onValueChange={(value) =>
                    setValue("prices.firstInstallment", value, {
                      shouldValidate: true,
                    })
                  }
                  disabled={isLoading}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select price" />
                  </SelectTrigger>
                  <SelectContent>
                    {pricesByType.firstInstallment.map((price) => (
                      <SelectItem key={price._id} value={price._id}>
                        ${price.amount.toFixed(2)} - {price.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                {errors.prices?.firstInstallment && (
                  <p className="text-sm text-red-600 mt-1">
                    {errors.prices.firstInstallment.message}
                  </p>
                )}
              </div>

              <div>
                <Label htmlFor="installment">Weekly (Early Bird) *</Label>
                <Select
                  onValueChange={(value) =>
                    setValue("prices.installment", value, {
                      shouldValidate: true,
                    })
                  }
                  disabled={isLoading}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select price" />
                  </SelectTrigger>
                  <SelectContent>
                    {pricesByType.installment.map((price) => (
                      <SelectItem key={price._id} value={price._id}>
                        ${price.amount.toFixed(2)}/week - {price.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                {errors.prices?.installment && (
                  <p className="text-sm text-red-600 mt-1">
                    {errors.prices.installment.message}
                  </p>
                )}
              </div>

              <div>
                <Label htmlFor="regularInstallment">Weekly (Regular) *</Label>
                <Select
                  onValueChange={(value) =>
                    setValue("prices.regularInstallment", value, {
                      shouldValidate: true,
                    })
                  }
                  disabled={isLoading}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select price" />
                  </SelectTrigger>
                  <SelectContent>
                    {pricesByType.regularInstallment.map((price) => (
                      <SelectItem key={price._id} value={price._id}>
                        ${price.amount.toFixed(2)}/week - {price.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                {errors.prices?.regularInstallment && (
                  <p className="text-sm text-red-600 mt-1">
                    {errors.prices.regularInstallment.message}
                  </p>
                )}
              </div>
            </div>
          </div>

          {/* Free */}
          <div>
            <h4 className="font-medium mb-3">Other</h4>
            <div className="max-w-xs">
              <Label htmlFor="free">Free Price *</Label>
              <Select
                onValueChange={(value) =>
                  setValue("prices.free", value, { shouldValidate: true })
                }
                disabled={isLoading}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select price" />
                </SelectTrigger>
                <SelectContent>
                  {pricesByType.free.map((price) => (
                    <SelectItem key={price._id} value={price._id}>
                      ${price.amount.toFixed(2)} - {price.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              {errors.prices?.free && (
                <p className="text-sm text-red-600 mt-1">
                  {errors.prices.free.message}
                </p>
              )}
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Status */}
      <Card>
        <CardHeader>
          <CardTitle>Status</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex items-center space-x-2">
            <Checkbox
              id="active"
              checked={active}
              onCheckedChange={(checked) =>
                setValue("active", checked as boolean)
              }
              disabled={isLoading}
            />
            <label
              htmlFor="active"
              className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
            >
              Active (Games are being played)
            </label>
          </div>

          <div className="flex items-center space-x-2">
            <Checkbox
              id="register"
              checked={registerOpen}
              onCheckedChange={(checked) =>
                setValue("register", checked as boolean)
              }
              disabled={isLoading}
            />
            <label
              htmlFor="register"
              className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
            >
              Registration Open (Teams can join)
            </label>
          </div>
        </CardContent>
      </Card>

      {/* Submit */}
      <div className="flex gap-4">
        <Button type="submit" disabled={isLoading}>
          {isLoading ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              Creating...
            </>
          ) : (
            "Create Division"
          )}
        </Button>
        <Button
          type="button"
          variant="outline"
          onClick={() => router.back()}
          disabled={isLoading}
        >
          Cancel
        </Button>
      </div>
    </form>
  );
}
